// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

export const zApiMeta = z.object({
  auth: z
    .object({
      schemes: z.array(z.string()).optional(),
    })
    .optional(),
  pylonAppId: z.string().optional(),
  posthog: z
    .object({
      apiKey: z.string().optional(),
      apiHost: z.string().optional(),
    })
    .optional(),
  allowSignup: z.boolean().optional(),
  allowInvites: z.boolean().optional(),
  allowCreateTenant: z.boolean().optional(),
  allowChangePassword: z.boolean().optional(),
});

export const zApiMetaAuth = z.object({
  schemes: z.array(z.string()).optional(),
});

export const zApiMetaPosthog = z.object({
  apiKey: z.string().optional(),
  apiHost: z.string().optional(),
});

export const zListApiMetaIntegration = z.array(
  z.object({
    name: z.string(),
    enabled: z.boolean(),
  }),
);

export const zApiMetaIntegration = z.object({
  name: z.string(),
  enabled: z.boolean(),
});

export const zApiErrors = z.object({
  errors: z.array(
    z.object({
      code: z.number().int().optional(),
      field: z.string().optional(),
      description: z.string(),
      docs_link: z.string().optional(),
    }),
  ),
});

export const zApiError = z.object({
  code: z.number().int().optional(),
  field: z.string().optional(),
  description: z.string(),
  docs_link: z.string().optional(),
});

export const zPaginationResponse = z.object({
  current_page: z.coerce.bigint().optional(),
  next_page: z.coerce.bigint().optional(),
  num_pages: z.coerce.bigint().optional(),
});

export const zApiResourceMeta = z.object({
  id: z.string().min(0).max(36),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
});

export const zUser = z.object({
  metadata: zApiResourceMeta,
  name: z.string().optional(),
  email: z.string().email(),
  emailVerified: z.boolean(),
  hasPassword: z.boolean().optional(),
  emailHash: z.string().optional(),
  userToken: z.string(),
});

export const zUserTenantPublic = z.object({
  email: z.string().email(),
  name: z.string().optional(),
});

export const zUserLoginRequest = z.object({
  email: z.string().email(),
  password: z.string(),
});

export const zUserChangePasswordRequest = z.object({
  password: z.string(),
  newPassword: z.string(),
});

export const zUserRegisterRequest = z.object({
  name: z.string(),
  email: z.string().email(),
  password: z.string(),
});

export const zUserTenantMembershipsList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        user: zUserTenantPublic,
        role: z.enum(["OWNER", "ADMIN", "MEMBER"]),
        tenant: z
          .object({
            metadata: zApiResourceMeta,
            name: z.string(),
            slug: z.string(),
            analyticsOptOut: z.boolean().optional(),
            alertMemberEmails: z.boolean().optional(),
            version: z.enum(["V0", "V1"]),
          })
          .optional(),
      }),
    )
    .optional(),
});

export const zTenant = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  slug: z.string(),
  analyticsOptOut: z.boolean().optional(),
  alertMemberEmails: z.boolean().optional(),
  version: z.enum(["V0", "V1"]),
});

export const zTenantMember = z.object({
  metadata: zApiResourceMeta,
  user: zUserTenantPublic,
  role: z.enum(["OWNER", "ADMIN", "MEMBER"]),
  tenant: zTenant.optional(),
});

export const zTenantMemberList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zTenantMember).optional(),
});

export const zTenantMemberRole = z.enum(["OWNER", "ADMIN", "MEMBER"]);

export const zTenantResource = z.enum([
  "WORKER",
  "WORKER_SLOT",
  "EVENT",
  "WORKFLOW_RUN",
  "TASK_RUN",
  "CRON",
  "SCHEDULE",
]);

export const zTenantResourceLimit = z.object({
  metadata: zApiResourceMeta,
  resource: zTenantResource,
  limitValue: z.number().int(),
  alarmValue: z.number().int().optional(),
  value: z.number().int(),
  window: z.string().optional(),
  lastRefill: z.string().datetime().optional(),
});

export const zTenantResourcePolicy = z.object({
  limits: z.array(zTenantResourceLimit),
});

export const zCreateTenantInviteRequest = z.object({
  email: z.string(),
  role: zTenantMemberRole,
});

export const zUpdateTenantInviteRequest = z.object({
  role: zTenantMemberRole,
});

export const zTenantAlertingSettings = z.object({
  metadata: zApiResourceMeta,
  alertMemberEmails: z.boolean().optional(),
  enableWorkflowRunFailureAlerts: z.boolean().optional(),
  enableExpiringTokenAlerts: z.boolean().optional(),
  enableTenantResourceLimitAlerts: z.boolean().optional(),
  maxAlertingFrequency: z.string(),
  lastAlertedAt: z.string().datetime().optional(),
});

export const zTenantAlertEmailGroup = z.object({
  metadata: zApiResourceMeta,
  emails: z.array(z.string()),
});

export const zTenantAlertEmailGroupList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zTenantAlertEmailGroup).optional(),
});

export const zCreateTenantAlertEmailGroupRequest = z.object({
  emails: z.array(z.string()),
});

export const zUpdateTenantAlertEmailGroupRequest = z.object({
  emails: z.array(z.string()),
});

export const zTenantInvite = z.object({
  metadata: zApiResourceMeta,
  email: z.string(),
  role: zTenantMemberRole,
  tenantId: z.string(),
  tenantName: z.string().optional(),
  expires: z.string().datetime(),
});

export const zTenantInviteList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zTenantInvite).optional(),
});

export const zQueueMetrics = z.object({
  numQueued: z.number().int(),
  numRunning: z.number().int(),
  numPending: z.number().int(),
});

export const zTenantQueueMetrics = z.object({
  total: zQueueMetrics.optional(),
  workflow: z.object({}).optional(),
  queues: z.object({}).optional(),
});

export const zTenantStepRunQueueMetrics = z.object({
  queues: z.object({}).optional(),
});

export const zAcceptInviteRequest = z.object({
  invite: z.string().length(36),
});

export const zRejectInviteRequest = z.object({
  invite: z.string().length(36),
});

export const zTenantList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zTenant).optional(),
});

export const zCreateTenantRequest = z.object({
  name: z.string(),
  slug: z.string(),
});

export const zUpdateTenantRequest = z.object({
  name: z.string().optional(),
  analyticsOptOut: z.boolean().optional(),
  alertMemberEmails: z.boolean().optional(),
  enableWorkflowRunFailureAlerts: z.boolean().optional(),
  enableExpiringTokenAlerts: z.boolean().optional(),
  enableTenantResourceLimitAlerts: z.boolean().optional(),
  maxAlertingFrequency: z.string().optional(),
  version: z.enum(["V0", "V1"]).optional(),
});

export const zEvent = z.object({
  metadata: zApiResourceMeta,
  key: z.string(),
  tenant: zTenant.optional(),
  tenantId: z.string(),
  workflowRunSummary: z
    .object({
      pending: z.coerce.bigint().optional(),
      running: z.coerce.bigint().optional(),
      queued: z.coerce.bigint().optional(),
      succeeded: z.coerce.bigint().optional(),
      failed: z.coerce.bigint().optional(),
      cancelled: z.coerce.bigint().optional(),
    })
    .optional(),
  additionalMetadata: z.object({}).optional(),
});

export const zEventData = z.object({
  data: z.string(),
});

export const zCreateEventRequest = z.object({
  key: z.string(),
  data: z.object({}),
  additionalMetadata: z.object({}).optional(),
  priority: z.number().int().optional(),
  scope: z.string().optional(),
});

export const zBulkCreateEventRequest = z.object({
  events: z.array(zCreateEventRequest),
});

export const zBulkCreateEventResponse = z.object({
  metadata: zApiResourceMeta,
  events: z.array(zEvent),
});

export const zEventWorkflowRunSummary = z.object({
  pending: z.coerce.bigint().optional(),
  running: z.coerce.bigint().optional(),
  queued: z.coerce.bigint().optional(),
  succeeded: z.coerce.bigint().optional(),
  failed: z.coerce.bigint().optional(),
  cancelled: z.coerce.bigint().optional(),
});

export const zEventOrderByField = z.enum(["createdAt"]);

export const zEventOrderByDirection = z.enum(["asc", "desc"]);

export const zEventSearch = z.string();

export const zEventKeyList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(z.string()).optional(),
});

export const zEventKey = z.string();

export const zWorkflowId = z.string();

export const zEventList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zEvent).optional(),
});

export const zV1EventList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        key: z.string(),
        tenant: zTenant.optional(),
        tenantId: z.string(),
        workflowRunSummary: z.object({
          running: z.coerce.bigint(),
          queued: z.coerce.bigint(),
          succeeded: z.coerce.bigint(),
          failed: z.coerce.bigint(),
          cancelled: z.coerce.bigint(),
        }),
        additionalMetadata: z.object({}).optional(),
      }),
    )
    .optional(),
});

export const zV1FilterList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        tenantId: z.string(),
        workflowId: z.string().uuid().length(36),
        scope: z.string(),
        expression: z.string(),
        payload: z.object({}),
      }),
    )
    .optional(),
});

export const zV1Filter = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  workflowId: z.string().uuid().length(36),
  scope: z.string(),
  expression: z.string(),
  payload: z.object({}),
});

export const zRateLimit = z.object({
  key: z.string(),
  tenantId: z.string(),
  limitValue: z.number().int(),
  value: z.number().int(),
  window: z.string(),
  lastRefill: z.string().datetime(),
});

export const zRateLimitList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zRateLimit).optional(),
});

export const zRateLimitOrderByField = z.enum(["key", "value", "limitValue"]);

export const zRateLimitOrderByDirection = z.enum(["asc", "desc"]);

export const zReplayEventRequest = z.object({
  eventIds: z.array(z.string().uuid().length(36)),
});

export const zCancelEventRequest = z.object({
  eventIds: z.array(z.string().uuid().length(36)),
});

export const zWorkflow: z.ZodTypeAny = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  description: z.string().optional(),
  isPaused: z.boolean().optional(),
  versions: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        version: z.string(),
        order: z.number().int(),
        workflowId: z.string(),
        workflow: z
          .lazy(() => {
            return zWorkflow;
          })
          .optional(),
      }),
    )
    .optional(),
  tags: z
    .array(
      z.object({
        name: z.string(),
        color: z.string(),
      }),
    )
    .optional(),
  jobs: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        tenantId: z.string(),
        versionId: z.string(),
        name: z.string(),
        description: z.string().optional(),
        steps: z.array(
          z.object({
            metadata: zApiResourceMeta,
            readableId: z.string(),
            tenantId: z.string(),
            jobId: z.string(),
            action: z.string(),
            timeout: z.string().optional(),
            children: z.array(z.string()).optional(),
            parents: z.array(z.string()).optional(),
          }),
        ),
        timeout: z.string().optional(),
      }),
    )
    .optional(),
  tenantId: z.string(),
});

export const zWorkflowUpdateRequest = z.object({
  isPaused: z.boolean().optional(),
});

export const zWorkflowConcurrency = z.object({
  maxRuns: z.number().int(),
  limitStrategy: z.enum(["CANCEL_IN_PROGRESS", "DROP_NEWEST", "QUEUE_NEWEST", "GROUP_ROUND_ROBIN"]),
  getConcurrencyGroup: z.string(),
});

export const zWorkflowVersionMeta = z.object({
  metadata: zApiResourceMeta,
  version: z.string(),
  order: z.number().int(),
  workflowId: z.string(),
  workflow: zWorkflow.optional(),
});

export const zWorkflowVersion = z.object({
  metadata: zApiResourceMeta,
  version: z.string(),
  order: z.number().int(),
  workflowId: z.string(),
  sticky: z.string().optional(),
  defaultPriority: z.number().int().optional(),
  workflow: zWorkflow.optional(),
  concurrency: zWorkflowConcurrency.optional(),
  triggers: z
    .object({
      metadata: zApiResourceMeta.optional(),
      workflow_version_id: z.string().optional(),
      tenant_id: z.string().optional(),
      events: z
        .array(
          z.object({
            parent_id: z.string().optional(),
            event_key: z.string().optional(),
          }),
        )
        .optional(),
      crons: z
        .array(
          z.object({
            parent_id: z.string().optional(),
            cron: z.string().optional(),
          }),
        )
        .optional(),
    })
    .optional(),
  scheduleTimeout: z.string().optional(),
  jobs: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        tenantId: z.string(),
        versionId: z.string(),
        name: z.string(),
        description: z.string().optional(),
        steps: z.array(
          z.object({
            metadata: zApiResourceMeta,
            readableId: z.string(),
            tenantId: z.string(),
            jobId: z.string(),
            action: z.string(),
            timeout: z.string().optional(),
            children: z.array(z.string()).optional(),
            parents: z.array(z.string()).optional(),
          }),
        ),
        timeout: z.string().optional(),
      }),
    )
    .optional(),
});

export const zWorkflowVersionDefinition = z.object({
  rawDefinition: z.string(),
});

export const zWorkflowTag = z.object({
  name: z.string(),
  color: z.string(),
});

export const zWorkflowList = z.object({
  metadata: zApiResourceMeta.optional(),
  rows: z.array(zWorkflow).optional(),
  pagination: zPaginationResponse.optional(),
});

export const zWorkflowTriggers = z.object({
  metadata: zApiResourceMeta.optional(),
  workflow_version_id: z.string().optional(),
  tenant_id: z.string().optional(),
  events: z
    .array(
      z.object({
        parent_id: z.string().optional(),
        event_key: z.string().optional(),
      }),
    )
    .optional(),
  crons: z
    .array(
      z.object({
        parent_id: z.string().optional(),
        cron: z.string().optional(),
      }),
    )
    .optional(),
});

export const zWorkflowTriggerEventRef = z.object({
  parent_id: z.string().optional(),
  event_key: z.string().optional(),
});

export const zWorkflowTriggerCronRef = z.object({
  parent_id: z.string().optional(),
  cron: z.string().optional(),
});

export const zJob = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  versionId: z.string(),
  name: z.string(),
  description: z.string().optional(),
  steps: z.array(
    z.object({
      metadata: zApiResourceMeta,
      readableId: z.string(),
      tenantId: z.string(),
      jobId: z.string(),
      action: z.string(),
      timeout: z.string().optional(),
      children: z.array(z.string()).optional(),
      parents: z.array(z.string()).optional(),
    }),
  ),
  timeout: z.string().optional(),
});

export const zStep = z.object({
  metadata: zApiResourceMeta,
  readableId: z.string(),
  tenantId: z.string(),
  jobId: z.string(),
  action: z.string(),
  timeout: z.string().optional(),
  children: z.array(z.string()).optional(),
  parents: z.array(z.string()).optional(),
});

export const zWorkflowWorkersCount = z.object({
  freeSlotCount: z.number().int().optional(),
  maxSlotCount: z.number().int().optional(),
  workflowRunId: z.string().optional(),
});

export const zWorkflowRun: z.ZodTypeAny = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  workflowVersionId: z.string(),
  workflowVersion: zWorkflowVersion.optional(),
  status: z.enum(["PENDING", "RUNNING", "SUCCEEDED", "FAILED", "CANCELLED", "QUEUED", "BACKOFF"]),
  displayName: z.string().optional(),
  jobRuns: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        tenantId: z.string(),
        workflowRunId: z.string(),
        workflowRun: z
          .lazy(() => {
            return zWorkflowRun;
          })
          .optional(),
        jobId: z.string(),
        job: zJob.optional(),
        tickerId: z.string().optional(),
        stepRuns: z
          .array(
            z.object({
              metadata: zApiResourceMeta,
              tenantId: z.string(),
              jobRunId: z.string(),
              stepId: z.string(),
              step: zStep.optional(),
              childWorkflowsCount: z.number().int().optional(),
              parents: z.array(z.string()).optional(),
              childWorkflowRuns: z.array(z.string()).optional(),
              workerId: z.string().optional(),
              input: z.string().optional(),
              output: z.string().optional(),
              status: z.enum([
                "PENDING",
                "PENDING_ASSIGNMENT",
                "ASSIGNED",
                "RUNNING",
                "SUCCEEDED",
                "FAILED",
                "CANCELLED",
                "CANCELLING",
                "BACKOFF",
              ]),
              requeueAfter: z.string().datetime().optional(),
              result: z.object({}).optional(),
              error: z.string().optional(),
              startedAt: z.string().datetime().optional(),
              startedAtEpoch: z.number().int().optional(),
              finishedAt: z.string().datetime().optional(),
              finishedAtEpoch: z.number().int().optional(),
              timeoutAt: z.string().datetime().optional(),
              timeoutAtEpoch: z.number().int().optional(),
              cancelledAt: z.string().datetime().optional(),
              cancelledAtEpoch: z.number().int().optional(),
              cancelledReason: z.string().optional(),
              cancelledError: z.string().optional(),
            }),
          )
          .optional(),
        status: z.enum(["PENDING", "RUNNING", "SUCCEEDED", "FAILED", "CANCELLED", "BACKOFF"]),
        result: z.object({}).optional(),
        startedAt: z.string().datetime().optional(),
        finishedAt: z.string().datetime().optional(),
        timeoutAt: z.string().datetime().optional(),
        cancelledAt: z.string().datetime().optional(),
        cancelledReason: z.string().optional(),
        cancelledError: z.string().optional(),
      }),
    )
    .optional(),
  triggeredBy: z.object({
    metadata: zApiResourceMeta,
    parentWorkflowRunId: z.string().optional(),
    eventId: z.string().optional(),
    cronParentId: z.string().optional(),
    cronSchedule: z.string().optional(),
  }),
  input: z.object({}).optional(),
  error: z.string().optional(),
  startedAt: z.string().datetime().optional(),
  finishedAt: z.string().datetime().optional(),
  duration: z.number().int().optional(),
  parentId: z.string().uuid().length(36).optional(),
  parentStepRunId: z.string().uuid().length(36).optional(),
  additionalMetadata: z.object({}).optional(),
});

export const zWorkflowRunShape = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  workflowId: z.string().optional(),
  workflowVersionId: z.string(),
  workflowVersion: zWorkflowVersion.optional(),
  status: z.enum(["PENDING", "RUNNING", "SUCCEEDED", "FAILED", "CANCELLED", "QUEUED", "BACKOFF"]),
  displayName: z.string().optional(),
  jobRuns: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        tenantId: z.string(),
        workflowRunId: z.string(),
        workflowRun: zWorkflowRun.optional(),
        jobId: z.string(),
        job: zJob.optional(),
        tickerId: z.string().optional(),
        stepRuns: z
          .array(
            z.object({
              metadata: zApiResourceMeta,
              tenantId: z.string(),
              jobRunId: z.string(),
              stepId: z.string(),
              step: zStep.optional(),
              childWorkflowsCount: z.number().int().optional(),
              parents: z.array(z.string()).optional(),
              childWorkflowRuns: z.array(z.string()).optional(),
              workerId: z.string().optional(),
              input: z.string().optional(),
              output: z.string().optional(),
              status: z.enum([
                "PENDING",
                "PENDING_ASSIGNMENT",
                "ASSIGNED",
                "RUNNING",
                "SUCCEEDED",
                "FAILED",
                "CANCELLED",
                "CANCELLING",
                "BACKOFF",
              ]),
              requeueAfter: z.string().datetime().optional(),
              result: z.object({}).optional(),
              error: z.string().optional(),
              startedAt: z.string().datetime().optional(),
              startedAtEpoch: z.number().int().optional(),
              finishedAt: z.string().datetime().optional(),
              finishedAtEpoch: z.number().int().optional(),
              timeoutAt: z.string().datetime().optional(),
              timeoutAtEpoch: z.number().int().optional(),
              cancelledAt: z.string().datetime().optional(),
              cancelledAtEpoch: z.number().int().optional(),
              cancelledReason: z.string().optional(),
              cancelledError: z.string().optional(),
            }),
          )
          .optional(),
        status: z.enum(["PENDING", "RUNNING", "SUCCEEDED", "FAILED", "CANCELLED", "BACKOFF"]),
        result: z.object({}).optional(),
        startedAt: z.string().datetime().optional(),
        finishedAt: z.string().datetime().optional(),
        timeoutAt: z.string().datetime().optional(),
        cancelledAt: z.string().datetime().optional(),
        cancelledReason: z.string().optional(),
        cancelledError: z.string().optional(),
      }),
    )
    .optional(),
  triggeredBy: z.object({
    metadata: zApiResourceMeta,
    parentWorkflowRunId: z.string().optional(),
    eventId: z.string().optional(),
    cronParentId: z.string().optional(),
    cronSchedule: z.string().optional(),
  }),
  input: z.object({}).optional(),
  error: z.string().optional(),
  startedAt: z.string().datetime().optional(),
  finishedAt: z.string().datetime().optional(),
  duration: z.number().int().optional(),
  parentId: z.string().uuid().length(36).optional(),
  parentStepRunId: z.string().uuid().length(36).optional(),
  additionalMetadata: z.object({}).optional(),
});

export const zReplayWorkflowRunsRequest = z.object({
  workflowRunIds: z.array(z.string().uuid().length(36)),
});

export const zReplayWorkflowRunsResponse = z.object({
  workflowRuns: z.array(zWorkflowRun),
});

export const zWorkflowRunList = z.object({
  rows: z.array(zWorkflowRun).optional(),
  pagination: zPaginationResponse.optional(),
});

export const zScheduledWorkflows = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  workflowVersionId: z.string(),
  workflowId: z.string(),
  workflowName: z.string(),
  triggerAt: z.string().datetime(),
  input: z.object({}).optional(),
  additionalMetadata: z.object({}).optional(),
  workflowRunCreatedAt: z.string().datetime().optional(),
  workflowRunName: z.string().optional(),
  workflowRunStatus: z
    .enum(["PENDING", "RUNNING", "SUCCEEDED", "FAILED", "CANCELLED", "QUEUED", "BACKOFF"])
    .optional(),
  workflowRunId: z.string().uuid().length(36).optional(),
  method: z.enum(["DEFAULT", "API"]),
  priority: z.number().int().gte(1).lte(3).optional(),
});

export const zScheduledWorkflowsList = z.object({
  rows: z.array(zScheduledWorkflows).optional(),
  pagination: zPaginationResponse.optional(),
});

export const zScheduledWorkflowsOrderByField = z.enum(["triggerAt", "createdAt"]);

export const zScheduledRunStatus = z.enum([
  "PENDING",
  "RUNNING",
  "SUCCEEDED",
  "FAILED",
  "CANCELLED",
  "QUEUED",
  "SCHEDULED",
]);

export const zCronWorkflows = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  workflowVersionId: z.string(),
  workflowId: z.string(),
  workflowName: z.string(),
  cron: z.string(),
  name: z.string().optional(),
  input: z.object({}).optional(),
  additionalMetadata: z.object({}).optional(),
  enabled: z.boolean(),
  method: z.enum(["DEFAULT", "API"]),
  priority: z.number().int().gte(1).lte(3).optional(),
});

export const zCronWorkflowsList = z.object({
  rows: z.array(zCronWorkflows).optional(),
  pagination: zPaginationResponse.optional(),
});

export const zCronWorkflowsOrderByField = z.enum(["name", "createdAt"]);

export const zWorkflowRunOrderByField = z.enum([
  "createdAt",
  "startedAt",
  "finishedAt",
  "duration",
]);

export const zWorkflowRunOrderByDirection = z.enum(["ASC", "DESC"]);

export const zWorkflowRunsMetrics = z.object({
  counts: z
    .object({
      PENDING: z.number().int().optional(),
      RUNNING: z.number().int().optional(),
      SUCCEEDED: z.number().int().optional(),
      FAILED: z.number().int().optional(),
      QUEUED: z.number().int().optional(),
      CANCELLED: z.number().int().optional(),
    })
    .optional(),
});

export const zWorkflowRunsMetricsCounts = z.object({
  PENDING: z.number().int().optional(),
  RUNNING: z.number().int().optional(),
  SUCCEEDED: z.number().int().optional(),
  FAILED: z.number().int().optional(),
  QUEUED: z.number().int().optional(),
  CANCELLED: z.number().int().optional(),
});

export const zWorkflowRunStatus = z.enum([
  "PENDING",
  "RUNNING",
  "SUCCEEDED",
  "FAILED",
  "CANCELLED",
  "QUEUED",
  "BACKOFF",
]);

export const zWorkflowRunStatusList = z.array(zWorkflowRunStatus);

export const zWorkflowKind = z.enum(["FUNCTION", "DURABLE", "DAG"]);

export const zWorkflowKindList = z.array(zWorkflowKind);

export const zWorkflowRunsCancelRequest = z.object({
  workflowRunIds: z.array(z.string().uuid().length(36)),
});

export const zJobRunStatus = z.enum([
  "PENDING",
  "RUNNING",
  "SUCCEEDED",
  "FAILED",
  "CANCELLED",
  "BACKOFF",
]);

export const zStepRunStatus = z.enum([
  "PENDING",
  "PENDING_ASSIGNMENT",
  "ASSIGNED",
  "RUNNING",
  "SUCCEEDED",
  "FAILED",
  "CANCELLED",
  "CANCELLING",
  "BACKOFF",
]);

export const zJobRun = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  workflowRunId: z.string(),
  workflowRun: zWorkflowRun.optional(),
  jobId: z.string(),
  job: zJob.optional(),
  tickerId: z.string().optional(),
  stepRuns: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        tenantId: z.string(),
        jobRunId: z.string(),
        stepId: z.string(),
        step: zStep.optional(),
        childWorkflowsCount: z.number().int().optional(),
        parents: z.array(z.string()).optional(),
        childWorkflowRuns: z.array(z.string()).optional(),
        workerId: z.string().optional(),
        input: z.string().optional(),
        output: z.string().optional(),
        status: zStepRunStatus,
        requeueAfter: z.string().datetime().optional(),
        result: z.object({}).optional(),
        error: z.string().optional(),
        startedAt: z.string().datetime().optional(),
        startedAtEpoch: z.number().int().optional(),
        finishedAt: z.string().datetime().optional(),
        finishedAtEpoch: z.number().int().optional(),
        timeoutAt: z.string().datetime().optional(),
        timeoutAtEpoch: z.number().int().optional(),
        cancelledAt: z.string().datetime().optional(),
        cancelledAtEpoch: z.number().int().optional(),
        cancelledReason: z.string().optional(),
        cancelledError: z.string().optional(),
      }),
    )
    .optional(),
  status: zJobRunStatus,
  result: z.object({}).optional(),
  startedAt: z.string().datetime().optional(),
  finishedAt: z.string().datetime().optional(),
  timeoutAt: z.string().datetime().optional(),
  cancelledAt: z.string().datetime().optional(),
  cancelledReason: z.string().optional(),
  cancelledError: z.string().optional(),
});

export const zWorkflowRunTriggeredBy = z.object({
  metadata: zApiResourceMeta,
  parentWorkflowRunId: z.string().optional(),
  eventId: z.string().optional(),
  cronParentId: z.string().optional(),
  cronSchedule: z.string().optional(),
});

export const zStepRun = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  jobRunId: z.string(),
  stepId: z.string(),
  step: zStep.optional(),
  childWorkflowsCount: z.number().int().optional(),
  parents: z.array(z.string()).optional(),
  childWorkflowRuns: z.array(z.string()).optional(),
  workerId: z.string().optional(),
  input: z.string().optional(),
  output: z.string().optional(),
  status: zStepRunStatus,
  requeueAfter: z.string().datetime().optional(),
  result: z.object({}).optional(),
  error: z.string().optional(),
  startedAt: z.string().datetime().optional(),
  startedAtEpoch: z.number().int().optional(),
  finishedAt: z.string().datetime().optional(),
  finishedAtEpoch: z.number().int().optional(),
  timeoutAt: z.string().datetime().optional(),
  timeoutAtEpoch: z.number().int().optional(),
  cancelledAt: z.string().datetime().optional(),
  cancelledAtEpoch: z.number().int().optional(),
  cancelledReason: z.string().optional(),
  cancelledError: z.string().optional(),
});

export const zStepRunEventReason = z.enum([
  "REQUEUED_NO_WORKER",
  "REQUEUED_RATE_LIMIT",
  "SCHEDULING_TIMED_OUT",
  "ASSIGNED",
  "STARTED",
  "ACKNOWLEDGED",
  "FINISHED",
  "FAILED",
  "RETRYING",
  "CANCELLED",
  "TIMEOUT_REFRESHED",
  "REASSIGNED",
  "TIMED_OUT",
  "SLOT_RELEASED",
  "RETRIED_BY_USER",
  "WORKFLOW_RUN_GROUP_KEY_SUCCEEDED",
  "WORKFLOW_RUN_GROUP_KEY_FAILED",
]);

export const zStepRunEventSeverity = z.enum(["INFO", "WARNING", "CRITICAL"]);

export const zStepRunEvent = z.object({
  id: z.number().int(),
  timeFirstSeen: z.string().datetime(),
  timeLastSeen: z.string().datetime(),
  stepRunId: z.string().optional(),
  workflowRunId: z.string().optional(),
  reason: zStepRunEventReason,
  severity: zStepRunEventSeverity,
  message: z.string(),
  count: z.number().int(),
  data: z.object({}).optional(),
});

export const zStepRunEventList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zStepRunEvent).optional(),
});

export const zStepRunArchive = z.object({
  stepRunId: z.string(),
  order: z.number().int(),
  input: z.string().optional(),
  output: z.string().optional(),
  startedAt: z.string().datetime().optional(),
  error: z.string().optional(),
  retryCount: z.number().int(),
  createdAt: z.string().datetime(),
  startedAtEpoch: z.number().int().optional(),
  finishedAt: z.string().datetime().optional(),
  finishedAtEpoch: z.number().int().optional(),
  timeoutAt: z.string().datetime().optional(),
  timeoutAtEpoch: z.number().int().optional(),
  cancelledAt: z.string().datetime().optional(),
  cancelledAtEpoch: z.number().int().optional(),
  cancelledReason: z.string().optional(),
  cancelledError: z.string().optional(),
});

export const zStepRunArchiveList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zStepRunArchive).optional(),
});

export const zWorkerRuntimeInfo = z.object({
  sdkVersion: z.string().optional(),
  language: z.enum(["GOLANG", "PYTHON", "TYPESCRIPT"]).optional(),
  languageVersion: z.string().optional(),
  os: z.string().optional(),
  runtimeExtra: z.string().optional(),
});

export const zWorkerRuntimeSdks = z.enum(["GOLANG", "PYTHON", "TYPESCRIPT"]);

export const zWorkerList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        name: z.string(),
        type: z.enum(["SELFHOSTED", "MANAGED", "WEBHOOK"]),
        lastHeartbeatAt: z.string().datetime().optional(),
        lastListenerEstablished: z.string().datetime().optional(),
        actions: z.array(z.string()).optional(),
        slots: z
          .array(
            z.object({
              stepRunId: z.string().uuid(),
              actionId: z.string(),
              startedAt: z.string().datetime().optional(),
              timeoutAt: z.string().datetime().optional(),
              workflowRunId: z.string().uuid(),
              status: zStepRunStatus,
            }),
          )
          .optional(),
        recentStepRuns: z
          .array(
            z.object({
              metadata: zApiResourceMeta,
              actionId: z.string(),
              status: zStepRunStatus,
              startedAt: z.string().datetime().optional(),
              finishedAt: z.string().datetime().optional(),
              cancelledAt: z.string().datetime().optional(),
              workflowRunId: z.string().uuid(),
            }),
          )
          .optional(),
        status: z.enum(["ACTIVE", "INACTIVE", "PAUSED"]).optional(),
        maxRuns: z.number().int().optional(),
        availableRuns: z.number().int().optional(),
        dispatcherId: z.string().uuid().length(36).optional(),
        labels: z
          .array(
            z.object({
              metadata: zApiResourceMeta,
              key: z.string(),
              value: z.string().optional(),
            }),
          )
          .optional(),
        webhookUrl: z.string().optional(),
        webhookId: z.string().uuid().optional(),
        runtimeInfo: zWorkerRuntimeInfo.optional(),
      }),
    )
    .optional(),
});

export const zSemaphoreSlots = z.object({
  stepRunId: z.string().uuid(),
  actionId: z.string(),
  startedAt: z.string().datetime().optional(),
  timeoutAt: z.string().datetime().optional(),
  workflowRunId: z.string().uuid(),
  status: zStepRunStatus,
});

export const zRecentStepRuns = z.object({
  metadata: zApiResourceMeta,
  actionId: z.string(),
  status: zStepRunStatus,
  startedAt: z.string().datetime().optional(),
  finishedAt: z.string().datetime().optional(),
  cancelledAt: z.string().datetime().optional(),
  workflowRunId: z.string().uuid(),
});

export const zWorker = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  type: z.enum(["SELFHOSTED", "MANAGED", "WEBHOOK"]),
  lastHeartbeatAt: z.string().datetime().optional(),
  lastListenerEstablished: z.string().datetime().optional(),
  actions: z.array(z.string()).optional(),
  slots: z.array(zSemaphoreSlots).optional(),
  recentStepRuns: z.array(zRecentStepRuns).optional(),
  status: z.enum(["ACTIVE", "INACTIVE", "PAUSED"]).optional(),
  maxRuns: z.number().int().optional(),
  availableRuns: z.number().int().optional(),
  dispatcherId: z.string().uuid().length(36).optional(),
  labels: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        key: z.string(),
        value: z.string().optional(),
      }),
    )
    .optional(),
  webhookUrl: z.string().optional(),
  webhookId: z.string().uuid().optional(),
  runtimeInfo: zWorkerRuntimeInfo.optional(),
});

export const zWorkerLabel = z.object({
  metadata: zApiResourceMeta,
  key: z.string(),
  value: z.string().optional(),
});

export const zUpdateWorkerRequest = z.object({
  isPaused: z.boolean().optional(),
});

export const zApiToken = z.object({
  metadata: zApiResourceMeta,
  name: z.string().max(255),
  expiresAt: z.string().datetime(),
});

export const zCreateApiTokenRequest = z.object({
  name: z.string().max(255),
  expiresIn: z.string().optional(),
});

export const zCreateApiTokenResponse = z.object({
  token: z.string(),
});

export const zListApiTokensResponse = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zApiToken).optional(),
});

export const zRerunStepRunRequest = z.object({
  input: z.object({}),
});

export const zTriggerWorkflowRunRequest = z.object({
  input: z.object({}),
  additionalMetadata: z.object({}).optional(),
});

export const zScheduleWorkflowRunRequest = z.object({
  input: z.object({}),
  additionalMetadata: z.object({}),
  triggerAt: z.string().datetime(),
  priority: z.number().int().gte(1).lte(3).optional(),
});

export const zCreateCronWorkflowTriggerRequest = z.object({
  input: z.object({}),
  additionalMetadata: z.object({}),
  cronName: z.string(),
  cronExpression: z.string(),
  priority: z.number().int().gte(1).lte(3).optional(),
});

export const zCreatePullRequestFromStepRun = z.object({
  branchName: z.string(),
});

export const zGetStepRunDiffResponse = z.object({
  diffs: z.array(
    z.object({
      key: z.string(),
      original: z.string(),
      modified: z.string(),
    }),
  ),
});

export const zStepRunDiff = z.object({
  key: z.string(),
  original: z.string(),
  modified: z.string(),
});

export const zListPullRequestsResponse = z.object({
  pullRequests: z.array(
    z.object({
      repositoryOwner: z.string(),
      repositoryName: z.string(),
      pullRequestID: z.number().int(),
      pullRequestTitle: z.string(),
      pullRequestNumber: z.number().int(),
      pullRequestHeadBranch: z.string(),
      pullRequestBaseBranch: z.string(),
      pullRequestState: z.enum(["open", "closed"]),
    }),
  ),
});

export const zPullRequest = z.object({
  repositoryOwner: z.string(),
  repositoryName: z.string(),
  pullRequestID: z.number().int(),
  pullRequestTitle: z.string(),
  pullRequestNumber: z.number().int(),
  pullRequestHeadBranch: z.string(),
  pullRequestBaseBranch: z.string(),
  pullRequestState: z.enum(["open", "closed"]),
});

export const zPullRequestState = z.enum(["open", "closed"]);

export const zLogLine = z.object({
  createdAt: z.string().datetime(),
  message: z.string(),
  metadata: z.object({}),
});

export const zLogLineLevel = z.enum(["DEBUG", "INFO", "WARN", "ERROR"]);

export const zLogLineList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zLogLine).optional(),
});

export const zLogLineOrderByField = z.enum(["createdAt"]);

export const zLogLineOrderByDirection = z.enum(["asc", "desc"]);

export const zLogLineSearch = z.string();

export const zLogLineLevelField = z.array(zLogLineLevel);

export const zSnsIntegration = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string().uuid(),
  topicArn: z.string(),
  ingestUrl: z.string().optional(),
});

export const zListSnsIntegrations = z.object({
  pagination: zPaginationResponse,
  rows: z.array(zSnsIntegration),
});

export const zSlackWebhook = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string().uuid(),
  teamName: z.string(),
  teamId: z.string(),
  channelName: z.string(),
  channelId: z.string(),
});

export const zListSlackWebhooks = z.object({
  pagination: zPaginationResponse,
  rows: z.array(zSlackWebhook),
});

export const zCreateSnsIntegrationRequest = z.object({
  topicArn: z.string(),
});

export const zWorkflowMetrics = z.object({
  groupKeyRunsCount: z.number().int().optional(),
  groupKeyCount: z.number().int().optional(),
});

export const zWebhookWorker = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  url: z.string(),
});

export const zWebhookWorkerRequestMethod = z.enum(["GET", "POST", "PUT"]);

export const zWebhookWorkerRequest = z.object({
  created_at: z.string().datetime(),
  method: zWebhookWorkerRequestMethod,
  statusCode: z.number().int(),
});

export const zWebhookWorkerRequestListResponse = z.object({
  requests: z.array(zWebhookWorkerRequest).optional(),
});

export const zWebhookWorkerCreated = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  url: z.string(),
  secret: z.string(),
});

export const zWebhookWorkerCreateRequest = z.object({
  name: z.string(),
  url: z.string(),
  secret: z.string().min(32).optional(),
});

export const zWebhookWorkerCreateResponse = z.object({
  worker: zWebhookWorkerCreated.optional(),
});

export const zWebhookWorkerListResponse = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zWebhookWorker).optional(),
});

export const zV1TaskSummaryList = z.object({
  pagination: zPaginationResponse,
  rows: z.array(
    z.object({
      metadata: zApiResourceMeta,
      actionId: z.string().optional(),
      retryCount: z.number().int().optional(),
      attempt: z.number().int().optional(),
      additionalMetadata: z.object({}).optional(),
      children: z.array(z.object({})).optional(),
      createdAt: z.string().datetime(),
      displayName: z.string(),
      duration: z.number().int().optional(),
      errorMessage: z.string().optional(),
      finishedAt: z.string().datetime().optional(),
      input: z.object({}),
      numSpawnedChildren: z.number().int(),
      output: z.object({}),
      status: z.enum(["QUEUED", "RUNNING", "COMPLETED", "CANCELLED", "FAILED"]),
      startedAt: z.string().datetime().optional(),
      stepId: z.string().uuid().length(36).optional(),
      taskExternalId: z.string().uuid().length(36),
      taskId: z.number().int(),
      taskInsertedAt: z.string().datetime(),
      tenantId: z.string().uuid().length(36),
      type: z.enum(["DAG", "TASK"]),
      workflowId: z.string().uuid(),
      workflowName: z.string().optional(),
      workflowRunExternalId: z.string().uuid(),
      workflowVersionId: z.string().uuid().optional(),
    }),
  ),
});

export const zV1WorkflowRunDisplayNameList = z.object({
  pagination: zPaginationResponse,
  rows: z.array(
    z.object({
      metadata: zApiResourceMeta,
      displayName: z.string(),
    }),
  ),
});

export const zV1TaskSummary = z.object({
  metadata: zApiResourceMeta,
  actionId: z.string().optional(),
  retryCount: z.number().int().optional(),
  attempt: z.number().int().optional(),
  additionalMetadata: z.object({}).optional(),
  children: z.array(z.object({})).optional(),
  createdAt: z.string().datetime(),
  displayName: z.string(),
  duration: z.number().int().optional(),
  errorMessage: z.string().optional(),
  finishedAt: z.string().datetime().optional(),
  input: z.object({}),
  numSpawnedChildren: z.number().int(),
  output: z.object({}),
  status: z.enum(["QUEUED", "RUNNING", "COMPLETED", "CANCELLED", "FAILED"]),
  startedAt: z.string().datetime().optional(),
  stepId: z.string().uuid().length(36).optional(),
  taskExternalId: z.string().uuid().length(36),
  taskId: z.number().int(),
  taskInsertedAt: z.string().datetime(),
  tenantId: z.string().uuid().length(36),
  type: z.enum(["DAG", "TASK"]),
  workflowId: z.string().uuid(),
  workflowName: z.string().optional(),
  workflowRunExternalId: z.string().uuid(),
  workflowVersionId: z.string().uuid().optional(),
});

export const zV1DagChildren = z.object({
  dagId: z.string().uuid().optional(),
  children: z.array(zV1TaskSummary).optional(),
});

export const zV1TaskEventList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z
    .array(
      z.object({
        id: z.number().int(),
        taskId: z.string().uuid(),
        timestamp: z.string().datetime(),
        eventType: z.enum([
          "REQUEUED_NO_WORKER",
          "REQUEUED_RATE_LIMIT",
          "SCHEDULING_TIMED_OUT",
          "ASSIGNED",
          "STARTED",
          "FINISHED",
          "FAILED",
          "RETRYING",
          "CANCELLED",
          "TIMED_OUT",
          "REASSIGNED",
          "SLOT_RELEASED",
          "TIMEOUT_REFRESHED",
          "RETRIED_BY_USER",
          "SENT_TO_WORKER",
          "RATE_LIMIT_ERROR",
          "ACKNOWLEDGED",
          "CREATED",
          "QUEUED",
          "SKIPPED",
        ]),
        message: z.string(),
        errorMessage: z.string().optional(),
        output: z.string().optional(),
        workerId: z.string().uuid().optional(),
        taskDisplayName: z.string().optional(),
        retryCount: z.number().int().optional(),
        attempt: z.number().int().optional(),
      }),
    )
    .optional(),
});

export const zV1TaskStatus = z.enum(["QUEUED", "RUNNING", "COMPLETED", "CANCELLED", "FAILED"]);

export const zV1TaskRunMetrics = z.array(
  z.object({
    status: zV1TaskStatus,
    count: z.number().int(),
  }),
);

export const zV1TaskPointMetric = z.object({
  time: z.string().datetime(),
  SUCCEEDED: z.number().int(),
  FAILED: z.number().int(),
});

export const zV1TaskPointMetrics = z.object({
  results: z.array(zV1TaskPointMetric).optional(),
});

export const zV1TaskFilter = z.object({
  since: z.string().datetime(),
  until: z.string().datetime().optional(),
  statuses: z.array(zV1TaskStatus).optional(),
  workflowIds: z.array(z.string().uuid()).optional(),
  additionalMetadata: z.array(z.string()).optional(),
});

export const zV1CancelTaskRequest = z.object({
  externalIds: z.array(z.string().uuid().length(36)).optional(),
  filter: zV1TaskFilter.optional(),
});

export const zV1ReplayTaskRequest = z.object({
  externalIds: z.array(z.string().uuid().length(36)).optional(),
  filter: zV1TaskFilter.optional(),
});

export const zV1WorkflowRun = z.object({
  metadata: zApiResourceMeta,
  status: zV1TaskStatus,
  startedAt: z.string().datetime().optional(),
  finishedAt: z.string().datetime().optional(),
  duration: z.number().int().optional(),
  tenantId: z.string().uuid().length(36),
  additionalMetadata: z.object({}).optional(),
  displayName: z.string(),
  workflowId: z.string().uuid(),
  output: z.object({}),
  errorMessage: z.string().optional(),
  workflowVersionId: z.string().uuid().optional(),
  input: z.object({}),
  createdAt: z.string().datetime().optional(),
  parentTaskExternalId: z.string().uuid().length(36).optional(),
});

export const zV1WorkflowRunDetails = z.object({
  run: zV1WorkflowRun,
  taskEvents: z.array(
    z.object({
      id: z.number().int(),
      taskId: z.string().uuid(),
      timestamp: z.string().datetime(),
      eventType: z.enum([
        "REQUEUED_NO_WORKER",
        "REQUEUED_RATE_LIMIT",
        "SCHEDULING_TIMED_OUT",
        "ASSIGNED",
        "STARTED",
        "FINISHED",
        "FAILED",
        "RETRYING",
        "CANCELLED",
        "TIMED_OUT",
        "REASSIGNED",
        "SLOT_RELEASED",
        "TIMEOUT_REFRESHED",
        "RETRIED_BY_USER",
        "SENT_TO_WORKER",
        "RATE_LIMIT_ERROR",
        "ACKNOWLEDGED",
        "CREATED",
        "QUEUED",
        "SKIPPED",
      ]),
      message: z.string(),
      errorMessage: z.string().optional(),
      output: z.string().optional(),
      workerId: z.string().uuid().optional(),
      taskDisplayName: z.string().optional(),
      retryCount: z.number().int().optional(),
      attempt: z.number().int().optional(),
    }),
  ),
  shape: z.array(
    z.object({
      taskExternalId: z.string().uuid().length(36),
      stepId: z.string().uuid().length(36),
      childrenStepIds: z.array(z.string().uuid().length(36)),
      taskName: z.string(),
    }),
  ),
  tasks: z.array(zV1TaskSummary),
});

export const zV1TaskRunStatus = z.enum(["PENDING", "RUNNING", "COMPLETED", "FAILED", "CANCELLED"]);

export const zV1TriggerWorkflowRunRequest = z.object({
  workflowName: z.string(),
  input: z.object({}),
  additionalMetadata: z.object({}).optional(),
  priority: z.number().int().optional(),
});

export const zV1LogLine = z.object({
  createdAt: z.string().datetime(),
  message: z.string(),
  metadata: z.object({}),
  retryCount: z.number().int().optional(),
  attempt: z.number().int().optional(),
  level: z.enum(["DEBUG", "INFO", "WARN", "ERROR"]).optional(),
});

export const zV1LogLineLevel = z.enum(["DEBUG", "INFO", "WARN", "ERROR"]);

export const zV1LogLineList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zV1LogLine).optional(),
});

export const zV1TaskTiming = z.object({
  metadata: zApiResourceMeta,
  depth: z.number().int(),
  status: zV1TaskStatus,
  taskDisplayName: z.string(),
  taskExternalId: z.string().uuid().length(36),
  taskId: z.number().int(),
  taskInsertedAt: z.string().datetime(),
  tenantId: z.string().uuid().length(36),
  parentTaskExternalId: z.string().uuid().length(36).optional(),
  queuedAt: z.string().datetime().optional(),
  startedAt: z.string().datetime().optional(),
  finishedAt: z.string().datetime().optional(),
  workflowRunId: z.string().uuid().optional(),
  retryCount: z.number().int().optional(),
  attempt: z.number().int().optional(),
});

export const zV1TaskTimingList = z.object({
  pagination: zPaginationResponse,
  rows: z.array(zV1TaskTiming),
});

export const zV1CreateFilterRequest = z.object({
  workflowId: z.string().uuid().length(36),
  expression: z.string(),
  scope: z.string(),
  payload: z.object({}).optional(),
});

export const zTenantVersion = z.enum(["V0", "V1"]);

export const zV1TaskEvent = z.object({
  id: z.number().int(),
  taskId: z.string().uuid(),
  timestamp: z.string().datetime(),
  eventType: z.enum([
    "REQUEUED_NO_WORKER",
    "REQUEUED_RATE_LIMIT",
    "SCHEDULING_TIMED_OUT",
    "ASSIGNED",
    "STARTED",
    "FINISHED",
    "FAILED",
    "RETRYING",
    "CANCELLED",
    "TIMED_OUT",
    "REASSIGNED",
    "SLOT_RELEASED",
    "TIMEOUT_REFRESHED",
    "RETRIED_BY_USER",
    "SENT_TO_WORKER",
    "RATE_LIMIT_ERROR",
    "ACKNOWLEDGED",
    "CREATED",
    "QUEUED",
    "SKIPPED",
  ]),
  message: z.string(),
  errorMessage: z.string().optional(),
  output: z.string().optional(),
  workerId: z.string().uuid().optional(),
  taskDisplayName: z.string().optional(),
  retryCount: z.number().int().optional(),
  attempt: z.number().int().optional(),
});

export const zApiResourceMetaProperties = z.object({
  metadata: zApiResourceMeta,
});

export const zCommonResult = z.object({
  Success: z.boolean(),
  Message: z.string(),
});

export const zTenantParameter = z.string().uuid().length(36);

export const zModel = zApiResourceMetaProperties.merge(
  z.object({
    name: z.string(),
    model: z.string(),
    provider: z.string(),
    apiKey: z.string(),
    apiBase: z.string(),
    vendor: z.string(),
    description: z.string().optional(),
    family: z.string(),
    vision: z.boolean(),
    functionCalling: z.boolean(),
    jsonOutput: z.boolean(),
    tags: z.array(z.string()).optional(),
  }),
);

export const zModelFamily = z.enum(["r1", "openai", "unknown"]);

export const zModelTypes = z.enum([
  "OpenAIChatCompletionClient",
  "AzureOpenAIChatCompletionClient",
]);

export const zModelProperties = z.object({
  name: z.string(),
  model: z.string(),
  provider: z.string(),
  apiKey: z.string(),
  apiBase: z.string(),
  vendor: z.string(),
  description: z.string().optional(),
  family: z.string(),
  vision: z.boolean(),
  functionCalling: z.boolean(),
  jsonOutput: z.boolean(),
  tags: z.array(z.string()).optional(),
});

export const zModelList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zModel).optional(),
});

export const zFormField = z.object({
  type: z.enum(["text", "number", "boolean", "array", "object"]),
  name: z.string(),
  default_value: z.string().optional(),
  label: z.string().optional(),
  description: z.string().optional(),
  required: z.boolean().optional(),
  min: z.number().optional(),
  max: z.number().optional(),
  placeholder: z.string().optional(),
});

export const zSchemaForm = z.object({
  form_type: z.enum(["schema", "custom"]).optional(),
  form_name: z.string().optional(),
  title: z.string(),
  description: z.string().optional(),
  layout: z.enum(["vertical", "horizontal"]).optional(),
  fields: z.array(zFormField),
});

export const zModelRunProperties = z.object({
  llmMessages: z.object({}).optional(),
  llmResponse: z.object({}).optional(),
});

export const zModelRun = zApiResourceMetaProperties.merge(zModelRunProperties);

export const zModelRunList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zModelRun).optional(),
});

export const zModelRunUpsert = zModelRunProperties;

export const zSiteProperties = z.object({
  id: z.string(),
  tenant_id: z.string(),
  updated_at: z.string().optional(),
  created_at: z.string().optional(),
  enabled: z.boolean(),
  title: z.string(),
  description: z.string(),
  automation_enabled: z.boolean(),
  state: z.object({
    status: z.string().optional(),
  }),
});

export const zSite = zSiteProperties;

export const zSiteList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zSite).optional(),
});

export const zCreateSiteRequest = z.object({
  title: z.string(),
  description: z.string(),
  host: z.string().optional(),
});

export const zCreateSiteResponse = zSite;

export const zUpdateSiteRequest = z.object({
  title: z.string().optional(),
});

export const zSiteHostProperties = z.object({
  id: z.string(),
  title: z.string().optional(),
  description: z.string().optional(),
  host: z.string(),
});

export const zSiteHost = zSiteHostProperties;

export const zSiteHostList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zSiteHost).optional(),
});

export const zCreateSiteHostRequest = zSiteHostProperties;

export const zUpdateSiteHostRequest = zSiteHost;

export const zFrontendConfig = z.object({
  cookieAccessToken: z.string(),
  dashPath: z.string(),
  hotKeyDebug: z.string(),
  defaultTenantAccessToken: z.string(),
});

export const zSiderbarConfig = z.object({
  logo: z.string().optional(),
  sideritems: z
    .array(
      z.object({
        title: z.string(),
        url: z.string(),
        icon: z.string().optional(),
        defaultExpanded: z.boolean().optional(),
        adminOnly: z.boolean().optional(),
        children: z
          .array(
            z.object({
              title: z.string(),
              url: z.string(),
              icon: z.string().optional(),
              adminOnly: z.boolean().optional(),
            }),
          )
          .optional(),
      }),
    )
    .optional(),
  other: z
    .union([
      z.enum([
        "sys",
        "tenant",
        "assistant",
        "ag",
        "browser",
        "resource",
        "instagram",
        "social",
        "team",
        "adk",
      ]),
      z.enum([
        "ThoughtEvent",
        "TextMessage",
        "PlatformAccountFlowInput",
        "ChatMessageInput",
        "SocialAddFollowersInput",
        "SocialLoginInput",
        "TenantInitInput",
        "AskUserFunctionCallInput",
        "StartNewChatInput",
      ]),
      z.object({
        pagination: zPaginationResponse.optional(),
        rows: z
          .array(
            zApiResourceMetaProperties.merge(
              z.object({
                label: z.string().optional(),
                description: z.string().optional(),
                username: z.string(),
                email: z.string().optional(),
                password: z.string(),
                token: z.string().optional(),
                type: z.string().optional(),
                platform: z.string(),
                enabled: z.boolean().optional(),
                tags: z.array(z.string()).optional(),
                state: z.object({}).optional(),
                error: z.string().optional(),
              }),
            ),
          )
          .optional(),
      }),
      z.object({
        role: z.string().optional(),
        parts: z
          .array(
            z.object({
              text: z.string().optional(),
              video_metadata: z.object({}).optional(),
              thought: z.boolean().optional(),
              code_execution_result: z.object({}).optional(),
              executable_code: z.string().optional(),
              file_data: z.object({}).optional(),
              function_call: z.object({}).optional(),
              function_response: z.object({}).optional(),
              inline_data: z.object({}).optional(),
            }),
          )
          .optional(),
      }),
      z.object({
        text: z.string().optional(),
        video_metadata: z.object({}).optional(),
        thought: z.boolean().optional(),
        code_execution_result: z.object({}).optional(),
        executable_code: z.string().optional(),
        file_data: z.object({}).optional(),
        function_call: z.object({}).optional(),
        function_response: z.object({}).optional(),
        inline_data: z.object({}).optional(),
      }),
      z.object({
        pagination: zPaginationResponse.optional(),
        rows: z
          .array(
            zApiResourceMetaProperties.merge(
              z.object({
                id: z.string(),
                app_name: z.string(),
                user_id: z.string(),
                state: z.object({
                  type: z.enum(["RootAgentState"]).optional(),
                }),
                title: z.string().optional(),
                create_time: z.string(),
                update_time: z.string(),
              }),
            ),
          )
          .optional(),
      }),
      z.object({
        content: z.string().optional(),
      }),
      z.object({
        content: z.string().optional(),
      }),
    ])
    .optional(),
});

export const zDashSidebarItem = z.object({
  title: z.string(),
  url: z.string(),
  icon: z.string().optional(),
  defaultExpanded: z.boolean().optional(),
  adminOnly: z.boolean().optional(),
  children: z
    .array(
      z.object({
        title: z.string(),
        url: z.string(),
        icon: z.string().optional(),
        adminOnly: z.boolean().optional(),
      }),
    )
    .optional(),
});

export const zDashSidebarItemLeaf = z.object({
  title: z.string(),
  url: z.string(),
  icon: z.string().optional(),
  adminOnly: z.boolean().optional(),
});

export const zUpdateEndpointRequest = z.object({
  name: z.string().optional(),
  url: z.string().optional(),
  token: z.string().optional(),
});

export const zEndpoint = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  url: z.string(),
  token: z.string(),
  type: z.string(),
});

export const zEndpointList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zEndpoint).optional(),
});

export const zMtWorkerProperties = z.object({
  id: z.string().optional(),
  name: z.string().optional(),
});

export const zMtWorkerTask = z.object({
  id: z.string().optional(),
  name: z.string().optional(),
});

export const zAgentEventType = z.enum([
  "ThoughtEvent",
  "TextMessage",
  "PlatformAccountFlowInput",
  "ChatMessageInput",
  "SocialAddFollowersInput",
  "SocialLoginInput",
  "TenantInitInput",
  "AskUserFunctionCallInput",
  "StartNewChatInput",
]);

export const zFlowNames = z.enum([
  "sys",
  "tenant",
  "assistant",
  "ag",
  "browser",
  "resource",
  "instagram",
  "social",
  "team",
  "adk",
]);

export const zAgentRunnerInput = z.object({
  content: z.string().optional(),
});

export const zAgentRunnerOutput = z.object({
  content: z.string().optional(),
});

export const zAgentProperties = z.object({
  name: z.string(),
  description: z.string(),
  provider: z.string(),
  config: z.object({}),
  teamId: z.string(),
});

export const zAgent = zApiResourceMetaProperties.merge(zAgentProperties);

export const zAgentList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zAgent).optional(),
});

export const zAgentTopicTypes = z.enum([
  "user",
  "human",
  "instagram",
  "browser",
  "socioety",
  "code",
  "router",
  "research",
  "writer",
  "tenant",
  "closure",
  "response",
]);

export const zBrowserTask = z.object({
  content: z.string(),
});

export const zBrowserOpenTask = z.object({
  url: z.string(),
});

export const zBrowserConfig = z.object({
  persistent: z.boolean().optional(),
});

export const zScheduledItem = z.object({
  id: z.string(),
  type: z.enum(["cron", "scheduled", "delayed"]),
  trigger: z.string(),
  nextTrigger: z.string(),
  description: z.string(),
});

export const zAdkSessionState = z.object({
  type: z.enum(["RootAgentState"]).optional(),
});

export const zToolTypes = z.enum(["code_executor", "social_login"]);

export const zCodeExecutionInput = z.object({
  code: z.string(),
});

export const zCodeExecutionResult = z.object({
  output: z.string(),
  success: z.boolean(),
});

export const zSocialLoginResult = z.object({
  success: z.boolean(),
});

export const zPlatform = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  description: z.string().optional(),
  url: z.string(),
  loginUrl: z.string().optional(),
  properties: z.object({}).optional(),
  tags: z.array(z.string()).optional(),
});

export const zPlatformList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zPlatform).optional(),
});

export const zPlatformUpdate = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  description: z.string().optional(),
  url: z.string(),
  loginUrl: z.string().optional(),
  properties: z.object({}).optional(),
  tags: z.array(z.string()).optional(),
});

export const zPlatformAccountProperties = z.object({
  label: z.string().optional(),
  description: z.string().optional(),
  username: z.string(),
  email: z.string().optional(),
  password: z.string(),
  token: z.string().optional(),
  type: z.string().optional(),
  platform: z.string(),
  enabled: z.boolean().optional(),
  tags: z.array(z.string()).optional(),
  state: z.object({}).optional(),
  error: z.string().optional(),
});

export const zPlatformAccountCreate = zPlatformAccountProperties;

export const zPlatformAccount = zApiResourceMetaProperties.merge(zPlatformAccountProperties);

export const zPlatformAccountList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zPlatformAccount).optional(),
});

export const zPlatformAccountUpsert = zPlatformAccountProperties;

export const zAdkEventProperties = z.object({
  id: z.string(),
  app_name: z.string(),
  user_id: z.string(),
  session_id: z.string(),
  invocation_id: z.string(),
  author: z.string(),
  branch: z.string().optional(),
  timestamp: z.string(),
  content: z.object({
    role: z.string().optional(),
    parts: z
      .array(
        z.object({
          text: z.string().optional(),
          video_metadata: z.object({}).optional(),
          thought: z.boolean().optional(),
          code_execution_result: z.object({}).optional(),
          executable_code: z.string().optional(),
          file_data: z.object({}).optional(),
          function_call: z.object({}).optional(),
          function_response: z.object({}).optional(),
          inline_data: z.object({}).optional(),
        }),
      )
      .optional(),
  }),
  actions: z.object({}),
});

export const zAdkEventList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zApiResourceMetaProperties.merge(zAdkEventProperties)).optional(),
});

export const zAdkEvent = zApiResourceMetaProperties.merge(zAdkEventProperties);

export const zAdkEventUpsert = zAdkEventProperties;

export const zAdkEventOrderByField = z.enum(["createdAt"]);

export const zAdkAppProperties = z.object({
  id: z.string(),
  app_name: z.string(),
  user_id: z.string(),
  session_id: z.string(),
  invocation_id: z.string(),
  author: z.string(),
  branch: z.string(),
  timestamp: z.string(),
  content: z.object({}),
  actions: z.object({}),
});

export const zAdkAppList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zApiResourceMetaProperties.merge(zAdkAppProperties)).optional(),
});

export const zAdkApp = zApiResourceMetaProperties.merge(zAdkAppProperties);

export const zAdkAppUpsert = zAdkAppProperties;

export const zAdkAppTypes = z.enum(["root", "instagram_agent", "assistant", "open_deep_research"]);

export const zAdkSessionProperties = z.object({
  id: z.string(),
  app_name: z.string(),
  user_id: z.string(),
  state: zAdkSessionState,
  title: z.string().optional(),
  create_time: z.string(),
  update_time: z.string(),
});

export const zAdkSession = zApiResourceMetaProperties.merge(zAdkSessionProperties);

export const zAdkSessionList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zAdkSession).optional(),
});

export const zAdkSessionUpsert = zAdkSessionProperties;

export const zAdkUserStateProperties = z.object({
  id: z.string(),
  app_name: z.string(),
  user_id: z.string(),
  session_id: z.string(),
  invocation_id: z.string(),
  author: z.string(),
  branch: z.string(),
  timestamp: z.string(),
  content: z.object({}),
  actions: z.object({}),
});

export const zAdkUserState = zApiResourceMetaProperties.merge(zAdkUserStateProperties);

export const zAdkUserStateList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zAdkUserState).optional(),
});

export const zAdkUserStateUpsert = zAdkUserStateProperties;

export const zContent = z.object({
  role: z.string().optional(),
  parts: z
    .array(
      z.object({
        text: z.string().optional(),
        video_metadata: z.object({}).optional(),
        thought: z.boolean().optional(),
        code_execution_result: z.object({}).optional(),
        executable_code: z.string().optional(),
        file_data: z.object({}).optional(),
        function_call: z.object({}).optional(),
        function_response: z.object({}).optional(),
        inline_data: z.object({}).optional(),
      }),
    )
    .optional(),
});

export const zUserContent = z.object({
  role: z.enum(["user"]),
  parts: z.array(
    z.object({
      text: z.string().optional(),
      video_metadata: z.object({}).optional(),
      thought: z.boolean().optional(),
      code_execution_result: z.object({}).optional(),
      executable_code: z.string().optional(),
      file_data: z.object({}).optional(),
      function_call: z.object({}).optional(),
      function_response: z.object({}).optional(),
      inline_data: z.object({}).optional(),
    }),
  ),
});

export const zModelContent = z.object({
  role: z.enum(["model"]),
  parts: z.array(
    z.object({
      text: z.string().optional(),
      video_metadata: z.object({}).optional(),
      thought: z.boolean().optional(),
      code_execution_result: z.object({}).optional(),
      executable_code: z.string().optional(),
      file_data: z.object({}).optional(),
      function_call: z.object({}).optional(),
      function_response: z.object({}).optional(),
      inline_data: z.object({}).optional(),
    }),
  ),
});

export const zPart = z.object({
  text: z.string().optional(),
  video_metadata: z.object({}).optional(),
  thought: z.boolean().optional(),
  code_execution_result: z.object({}).optional(),
  executable_code: z.string().optional(),
  file_data: z.object({}).optional(),
  function_call: z.object({}).optional(),
  function_response: z.object({}).optional(),
  inline_data: z.object({}).optional(),
});

export const zFunctionResponse = z.object({
  id: z.string().optional().default(""),
  name: z.string(),
  response: z.object({}),
});

export const zArtifact = z.object({
  id: z.string().uuid().length(36),
  created_at: z.string().datetime(),
  updated_at: z.string(),
  tenant_id: z.string().uuid().length(36),
  user_id: z.string(),
  version: z.number().int(),
  session_id: z.string(),
  app_name: z.string(),
  filename: z.string(),
  mime_type: z.string().optional(),
  content: z.string(),
});

export const zArtifactList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zArtifact).optional(),
});

export const zSaveArtifactRequest = z.object({
  app_name: z.string(),
  user_id: z.string(),
  session_id: z.string().optional(),
  filename: z.string().optional(),
  content: z.string().optional(),
});

export const zPost = z.object({
  metadata: zApiResourceMeta,
  title: z.string(),
  content: z.string(),
});

export const zPostList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zPost).optional(),
});

export const zCreatePostRequest = z.object({
  siteId: z.string().uuid().length(36),
  title: z.string().min(3).max(200),
  content: z.string().min(50).max(10240),
  slug: z.string().min(3).max(200),
  authorId: z.string().uuid().length(36).optional(),
  status: z.enum(["draft", "published"]).optional(),
});

export const zSandbox = z.object({
  id: z.string(),
  type: z.string(),
  url: z.string(),
});

export const zMtmInfo = z.object({
  message: z.string().optional(),
});

export const zBot = z.object({
  id: z.string(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
  name: z.string(),
  description: z.string(),
  config: z.object({
    public_server: z.string(),
    private_server: z.string(),
    frontend_url: z.string(),
    local_http_server_enabled: z.boolean(),
    local_http_server_port: z.number().int(),
    adb_server_enabled: z.boolean(),
    adb_server_port: z.number().int().optional().default(5555),
  }),
});

export const zBotList = z.object({
  pagination: zPaginationResponse,
  rows: z.array(zBot),
});

export const zBotConfig = z.object({
  public_server: z.string(),
  private_server: z.string(),
  frontend_url: z.string(),
  local_http_server_enabled: z.boolean(),
  local_http_server_port: z.number().int(),
  adb_server_enabled: z.boolean(),
  adb_server_port: z.number().int().optional().default(5555),
});

export const zBotLocalState = z.object({
  bot_id: z.string(),
  device_type: z.enum(["unknown", "android", "ios", "web"]),
  host_name: z.string(),
});

export const zSbWorkerProfile = z.object({
  frontendUrl: z.string(),
  isDebug: z.boolean(),
  autoStart: z.boolean(),
  defaultProfileName: z.string(),
  defaultProfileUrl: z.string(),
});

export const zSbOutbound = z.object({
  id: z.string().optional(),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
  tag: z.string().optional(),
  type: z.string().optional(),
  server: z.string().optional(),
  server_port: z.number().int().optional(),
  uuid: z.string().optional(),
});

export const zSbImportRequest = z.object({
  url: z.string(),
});

export const zV1TaskGetResponse = zV1TaskSummary;

export const zV1TaskEventListResponse = zV1TaskEventList;

export const zV1LogLineListResponse = zV1LogLineList;

export const zV1DagListTasksResponse = z.array(zV1DagChildren);

export const zV1WorkflowRunListResponse = zV1TaskSummaryList;

export const zV1WorkflowRunDisplayNamesListResponse = zV1WorkflowRunDisplayNameList;

export const zV1WorkflowRunCreateResponse = zV1WorkflowRunDetails;

export const zV1WorkflowRunGetResponse = zV1WorkflowRunDetails;

export const zV1WorkflowRunTaskEventsListResponse = zV1TaskEventList;

export const zV1WorkflowRunGetTimingsResponse = zV1TaskTimingList;

export const zV1TaskListStatusMetricsResponse = zV1TaskRunMetrics;

export const zV1TaskGetPointMetricsResponse = zV1TaskPointMetrics;

export const zV1EventListResponse = zV1EventList;

export const zV1FilterListResponse = zV1FilterList;

export const zV1FilterCreateResponse = zV1Filter;

export const zV1FilterDeleteResponse = zV1Filter;

export const zV1FilterGetResponse = zV1Filter;

export const zMetadataGetResponse = zApiMeta;

export const zCloudMetadataGetResponse = zApiErrors;

export const zMetadataListIntegrationsResponse = zListApiMetaIntegration;

export const zUserUpdateLoginResponse = zUser;

export const zSnsListResponse = zListSnsIntegrations;

export const zSnsCreateResponse = zSnsIntegration;

export const zAlertEmailGroupListResponse = zTenantAlertEmailGroupList;

export const zAlertEmailGroupCreateResponse = zTenantAlertEmailGroup;

export const zTenantResourcePolicyGetResponse = zTenantResourcePolicy;

export const zAlertEmailGroupDeleteResponse = z.void();

export const zAlertEmailGroupUpdateResponse = zTenantAlertEmailGroup;

export const zSnsDeleteResponse = z.void();

export const zSlackWebhookListResponse = zListSlackWebhooks;

export const zSlackWebhookDeleteResponse = z.void();

export const zUserGetCurrentResponse = zUser;

export const zUserUpdatePasswordResponse = zUser;

export const zUserCreateResponse = zUser;

export const zUserUpdateLogoutResponse = zUser;

export const zTenantMembershipsListResponse = zUserTenantMembershipsList;

export const zUserListTenantInvitesResponse = zTenantInviteList;

export const zTenantCreateResponse = zTenant;

export const zTenantUpdateResponse = zTenant;

export const zTenantAlertingSettingsGetResponse = zTenantAlertingSettings;

export const zTenantInviteListResponse = zTenantInviteList;

export const zTenantInviteCreateResponse = zTenantInvite;

export const zTenantInviteDeleteResponse = zTenantInvite;

export const zTenantInviteUpdateResponse = zTenantInvite;

export const zApiTokenListResponse = zListApiTokensResponse;

export const zApiTokenCreateResponse = zCreateApiTokenResponse;

export const zApiTokenUpdateRevokeResponse = z.void();

export const zTenantGetQueueMetricsResponse = zTenantQueueMetrics;

export const zTenantGetStepRunQueueMetricsResponse = zTenantStepRunQueueMetrics;

export const zEventListResponse = zEventList;

export const zEventCreateResponse = zEvent;

export const zEventCreateBulkResponse = zBulkCreateEventResponse;

export const zEventUpdateReplayResponse = zEventList;

export const zEventUpdateCancelResponse = z.object({
  workflowRunIds: z.array(z.string().uuid().length(36)).optional(),
});

export const zRateLimitListResponse = zRateLimitList;

export const zTenantMemberListResponse = zTenantMemberList;

export const zTenantMemberDeleteResponse = zTenantMember;

export const zEventGetResponse = zEvent;

export const zEventDataGetResponse = zEventData;

export const zEventKeyListResponse = zEventKeyList;

export const zWorkflowListResponse = zWorkflowList;

export const zScheduledWorkflowRunCreateResponse = zScheduledWorkflows;

export const zWorkflowScheduledListResponse = zScheduledWorkflowsList;

export const zWorkflowScheduledDeleteResponse = z.void();

export const zWorkflowScheduledGetResponse = zScheduledWorkflows;

export const zCronWorkflowTriggerCreateResponse = zCronWorkflows;

export const zCronWorkflowListResponse = zCronWorkflowsList;

export const zWorkflowCronDeleteResponse = z.void();

export const zWorkflowCronGetResponse = zCronWorkflows;

export const zWorkflowRunCancelResponse = z.object({
  workflowRunIds: z.array(z.string().uuid().length(36)).optional(),
});

export const zWorkflowDeleteResponse = z.void();

export const zWorkflowGetResponse = zWorkflow;

export const zWorkflowUpdateResponse = zWorkflow;

export const zWorkflowVersionGetResponse = zWorkflowVersion;

export const zWorkflowRunCreateResponse = zWorkflowRun;

export const zWorkflowGetMetricsResponse = zWorkflowMetrics;

export const zLogLineListResponse = zLogLineList;

export const zStepRunListEventsResponse = zStepRunEventList;

export const zWorkflowRunListStepRunEventsResponse = zStepRunEventList;

export const zStepRunListArchivesResponse = zStepRunArchiveList;

export const zWorkflowGetWorkersCountResponse = zWorkflowWorkersCount;

export const zWorkflowRunListResponse = zWorkflowRunList;

export const zWorkflowRunUpdateReplayResponse = zReplayWorkflowRunsResponse;

export const zWorkflowRunGetMetricsResponse = zWorkflowRunsMetrics;

export const zWorkflowRunGetResponse = zWorkflowRun;

export const zWorkflowRunGetShapeResponse = zWorkflowRunShape;

export const zStepRunGetResponse = zStepRun;

export const zStepRunUpdateRerunResponse = zStepRun;

export const zStepRunUpdateCancelResponse = zStepRun;

export const zStepRunGetSchemaResponse = z.object({});

export const zWorkerListResponse = zWorkerList;

export const zWorkerGetResponse = zWorker;

export const zWorkerUpdateResponse = zWorker;

export const zWebhookListResponse = zWebhookWorkerListResponse;

export const zWebhookCreateResponse = zWebhookWorkerCreated;

export const zWebhookRequestsListResponse = zWebhookWorkerRequestListResponse;

export const zWorkflowRunGetInputResponse = z.object({});

export const zInfoGetVersionResponse = z.object({
  version: z.string(),
});

export const zSiteListResponse = zSiteList;

export const zSiteCreateResponse = zSite;

export const zSiteGetResponse = zSite;

export const zSiteUpdateResponse = zSite;

export const zSiteGetByHostResponse = zSite;

export const zSiteHostListResponse = zSiteHostList;

export const zSiteHostCreateResponse = zSiteHost;

export const zSiteHostGetResponse = zSiteHost;

export const zSiteHostUpdateResponse = zSiteHost;

export const zFrontendGetConfigResponse = zFrontendConfig;

export const zFrontendGetSiderbarResponse = zSiderbarConfig;

export const zEndpointListResponse = zEndpointList;

export const zEndpointUpdateResponse = zEndpoint;

export const zMtworkerGetTasksResponse = zMtWorkerTask;

export const zPostListPublicResponse = zPostList;

export const zPostGetResponse = zPost;

export const zPostListResponse = zPostList;

export const zPostCreateResponse = zPost;

export const zArtifactListResponse = zArtifactList;

export const zArtifactGetResponse = zArtifact;

export const zArtifactSaveResponse = zArtifact;

export const zSandboxGetResponse = zSandbox;

export const zMtmHelloResponse = zMtmInfo;

export const zScriptsByNameResponse = z.string();

export const zFrpsHandlerResponse = z.object({});

export const zSingboxGetWorkerProfileResponse = zSbWorkerProfile;

export const zSingboxSubscribeResponse = z.object({});

export const zSingboxGeoipCnSrsResponse = z.string();

export const zSingboxGetOutboundsResponse = zSbOutbound;

export const zSingboxImportOutboundsResponse = zSbOutbound;

export const zBotListResponse = zBotList;

export const zBotGetResponse = zBot;

export const zBotHeartbeatResponse = zBotConfig;
