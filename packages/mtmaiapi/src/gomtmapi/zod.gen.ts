// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

export const zApiMeta = z.object({
  auth: z
    .object({
      schemes: z.array(z.string()).optional(),
    })
    .optional(),
  pylonAppId: z.string().optional(),
  posthog: z
    .object({
      apiKey: z.string().optional(),
      apiHost: z.string().optional(),
    })
    .optional(),
  allowSignup: z.boolean().optional(),
  allowInvites: z.boolean().optional(),
  allowCreateTenant: z.boolean().optional(),
  allowChangePassword: z.boolean().optional(),
});

export const zApiMetaAuth = z.object({
  schemes: z.array(z.string()).optional(),
});

export const zApiMetaPosthog = z.object({
  apiKey: z.string().optional(),
  apiHost: z.string().optional(),
});

export const zListApiMetaIntegration = z.array(
  z.object({
    name: z.string(),
    enabled: z.boolean(),
  }),
);

export const zApiMetaIntegration = z.object({
  name: z.string(),
  enabled: z.boolean(),
});

export const zApiErrors = z.object({
  errors: z.array(
    z.object({
      code: z.number().int().optional(),
      field: z.string().optional(),
      description: z.string(),
      docs_link: z.string().optional(),
    }),
  ),
});

export const zApiError = z.object({
  code: z.number().int().optional(),
  field: z.string().optional(),
  description: z.string(),
  docs_link: z.string().optional(),
});

export const zPaginationResponse = z.object({
  current_page: z.coerce.bigint().optional(),
  next_page: z.coerce.bigint().optional(),
  num_pages: z.coerce.bigint().optional(),
});

export const zApiResourceMeta = z.object({
  id: z.string().min(0).max(36),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
});

export const zUser = z.object({
  metadata: zApiResourceMeta,
  name: z.string().optional(),
  email: z.string().email(),
  emailVerified: z.boolean(),
  hasPassword: z.boolean().optional(),
  emailHash: z.string().optional(),
  userToken: z.string(),
});

export const zUserTenantPublic = z.object({
  email: z.string().email(),
  name: z.string().optional(),
});

export const zUserLoginRequest = z.object({
  email: z.string().email(),
  password: z.string(),
});

export const zUserChangePasswordRequest = z.object({
  password: z.string(),
  newPassword: z.string(),
});

export const zUserRegisterRequest = z.object({
  name: z.string(),
  email: z.string().email(),
  password: z.string(),
});

export const zUserTenantMembershipsList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        user: zUserTenantPublic,
        role: z.enum(["OWNER", "ADMIN", "MEMBER"]),
        tenant: z
          .object({
            metadata: zApiResourceMeta,
            name: z.string(),
            slug: z.string(),
            analyticsOptOut: z.boolean().optional(),
            alertMemberEmails: z.boolean().optional(),
            version: z.enum(["V0", "V1"]),
          })
          .optional(),
      }),
    )
    .optional(),
});

export const zTenant = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  slug: z.string(),
  analyticsOptOut: z.boolean().optional(),
  alertMemberEmails: z.boolean().optional(),
  version: z.enum(["V0", "V1"]),
});

export const zTenantMember = z.object({
  metadata: zApiResourceMeta,
  user: zUserTenantPublic,
  role: z.enum(["OWNER", "ADMIN", "MEMBER"]),
  tenant: zTenant.optional(),
});

export const zTenantMemberList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zTenantMember).optional(),
});

export const zTenantMemberRole = z.enum(["OWNER", "ADMIN", "MEMBER"]);

export const zTenantResource = z.enum([
  "WORKER",
  "WORKER_SLOT",
  "EVENT",
  "WORKFLOW_RUN",
  "TASK_RUN",
  "CRON",
  "SCHEDULE",
]);

export const zTenantResourceLimit = z.object({
  metadata: zApiResourceMeta,
  resource: zTenantResource,
  limitValue: z.number().int(),
  alarmValue: z.number().int().optional(),
  value: z.number().int(),
  window: z.string().optional(),
  lastRefill: z.string().datetime().optional(),
});

export const zTenantResourcePolicy = z.object({
  limits: z.array(zTenantResourceLimit),
});

export const zCreateTenantInviteRequest = z.object({
  email: z.string(),
  role: zTenantMemberRole,
});

export const zUpdateTenantInviteRequest = z.object({
  role: zTenantMemberRole,
});

export const zTenantAlertingSettings = z.object({
  metadata: zApiResourceMeta,
  alertMemberEmails: z.boolean().optional(),
  enableWorkflowRunFailureAlerts: z.boolean().optional(),
  enableExpiringTokenAlerts: z.boolean().optional(),
  enableTenantResourceLimitAlerts: z.boolean().optional(),
  maxAlertingFrequency: z.string(),
  lastAlertedAt: z.string().datetime().optional(),
});

export const zTenantAlertEmailGroup = z.object({
  metadata: zApiResourceMeta,
  emails: z.array(z.string()),
});

export const zTenantAlertEmailGroupList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zTenantAlertEmailGroup).optional(),
});

export const zCreateTenantAlertEmailGroupRequest = z.object({
  emails: z.array(z.string()),
});

export const zUpdateTenantAlertEmailGroupRequest = z.object({
  emails: z.array(z.string()),
});

export const zTenantInvite = z.object({
  metadata: zApiResourceMeta,
  email: z.string(),
  role: zTenantMemberRole,
  tenantId: z.string(),
  tenantName: z.string().optional(),
  expires: z.string().datetime(),
});

export const zTenantInviteList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zTenantInvite).optional(),
});

export const zQueueMetrics = z.object({
  numQueued: z.number().int(),
  numRunning: z.number().int(),
  numPending: z.number().int(),
});

export const zTenantQueueMetrics = z.object({
  total: zQueueMetrics.optional(),
  workflow: z.object({}).optional(),
  queues: z.object({}).optional(),
});

export const zTenantStepRunQueueMetrics = z.object({
  queues: z.object({}).optional(),
});

export const zAcceptInviteRequest = z.object({
  invite: z.string().length(36),
});

export const zRejectInviteRequest = z.object({
  invite: z.string().length(36),
});

export const zTenantList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zTenant).optional(),
});

export const zCreateTenantRequest = z.object({
  name: z.string(),
  slug: z.string(),
});

export const zUpdateTenantRequest = z.object({
  name: z.string().optional(),
  analyticsOptOut: z.boolean().optional(),
  alertMemberEmails: z.boolean().optional(),
  enableWorkflowRunFailureAlerts: z.boolean().optional(),
  enableExpiringTokenAlerts: z.boolean().optional(),
  enableTenantResourceLimitAlerts: z.boolean().optional(),
  maxAlertingFrequency: z.string().optional(),
  version: z.enum(["V0", "V1"]).optional(),
});

export const zRateLimit = z.object({
  key: z.string(),
  tenantId: z.string(),
  limitValue: z.number().int(),
  value: z.number().int(),
  window: z.string(),
  lastRefill: z.string().datetime(),
});

export const zRateLimitList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zRateLimit).optional(),
});

export const zRateLimitOrderByField = z.enum(["key", "value", "limitValue"]);

export const zRateLimitOrderByDirection = z.enum(["asc", "desc"]);

export const zWorkflowUpdateRequest = z.object({
  isPaused: z.boolean().optional(),
});

export const zWorkflowConcurrency = z.object({
  maxRuns: z.number().int(),
  limitStrategy: z.enum(["CANCEL_IN_PROGRESS", "DROP_NEWEST", "QUEUE_NEWEST", "GROUP_ROUND_ROBIN"]),
  getConcurrencyGroup: z.string(),
});

export const zWorkflowVersionMeta: z.ZodTypeAny = z.object({
  metadata: zApiResourceMeta,
  version: z.string(),
  order: z.number().int(),
  workflowId: z.string(),
  workflow: z
    .object({
      metadata: zApiResourceMeta,
      name: z.string(),
      description: z.string().optional(),
      isPaused: z.boolean().optional(),
      versions: z
        .array(
          z.lazy(() => {
            return zWorkflowVersionMeta;
          }),
        )
        .optional(),
      tags: z
        .array(
          z.object({
            name: z.string(),
            color: z.string(),
          }),
        )
        .optional(),
      jobs: z
        .array(
          z.object({
            metadata: zApiResourceMeta,
            tenantId: z.string(),
            versionId: z.string(),
            name: z.string(),
            description: z.string().optional(),
            steps: z.array(
              z.object({
                metadata: zApiResourceMeta,
                readableId: z.string(),
                tenantId: z.string(),
                jobId: z.string(),
                action: z.string(),
                timeout: z.string().optional(),
                children: z.array(z.string()).optional(),
                parents: z.array(z.string()).optional(),
              }),
            ),
            timeout: z.string().optional(),
          }),
        )
        .optional(),
      tenantId: z.string(),
    })
    .optional(),
});

export const zWorkflowVersion = z.object({
  metadata: zApiResourceMeta,
  version: z.string(),
  order: z.number().int(),
  workflowId: z.string(),
  sticky: z.string().optional(),
  defaultPriority: z.number().int().optional(),
  workflow: z
    .object({
      metadata: zApiResourceMeta,
      name: z.string(),
      description: z.string().optional(),
      isPaused: z.boolean().optional(),
      versions: z.array(zWorkflowVersionMeta).optional(),
      tags: z
        .array(
          z.object({
            name: z.string(),
            color: z.string(),
          }),
        )
        .optional(),
      jobs: z
        .array(
          z.object({
            metadata: zApiResourceMeta,
            tenantId: z.string(),
            versionId: z.string(),
            name: z.string(),
            description: z.string().optional(),
            steps: z.array(
              z.object({
                metadata: zApiResourceMeta,
                readableId: z.string(),
                tenantId: z.string(),
                jobId: z.string(),
                action: z.string(),
                timeout: z.string().optional(),
                children: z.array(z.string()).optional(),
                parents: z.array(z.string()).optional(),
              }),
            ),
            timeout: z.string().optional(),
          }),
        )
        .optional(),
      tenantId: z.string(),
    })
    .optional(),
  concurrency: zWorkflowConcurrency.optional(),
  triggers: z
    .object({
      metadata: zApiResourceMeta.optional(),
      workflow_version_id: z.string().optional(),
      tenant_id: z.string().optional(),
      events: z
        .array(
          z.object({
            parent_id: z.string().optional(),
            event_key: z.string().optional(),
          }),
        )
        .optional(),
      crons: z
        .array(
          z.object({
            parent_id: z.string().optional(),
            cron: z.string().optional(),
          }),
        )
        .optional(),
    })
    .optional(),
  scheduleTimeout: z.string().optional(),
  jobs: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        tenantId: z.string(),
        versionId: z.string(),
        name: z.string(),
        description: z.string().optional(),
        steps: z.array(
          z.object({
            metadata: zApiResourceMeta,
            readableId: z.string(),
            tenantId: z.string(),
            jobId: z.string(),
            action: z.string(),
            timeout: z.string().optional(),
            children: z.array(z.string()).optional(),
            parents: z.array(z.string()).optional(),
          }),
        ),
        timeout: z.string().optional(),
      }),
    )
    .optional(),
});

export const zWorkflowVersionDefinition = z.object({
  rawDefinition: z.string(),
});

export const zWorkflowTag = z.object({
  name: z.string(),
  color: z.string(),
});

export const zWorkflowList = z.object({
  metadata: zApiResourceMeta.optional(),
  rows: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        name: z.string(),
        description: z.string().optional(),
        isPaused: z.boolean().optional(),
        versions: z.array(zWorkflowVersionMeta).optional(),
        tags: z.array(zWorkflowTag).optional(),
        jobs: z
          .array(
            z.object({
              metadata: zApiResourceMeta,
              tenantId: z.string(),
              versionId: z.string(),
              name: z.string(),
              description: z.string().optional(),
              steps: z.array(
                z.object({
                  metadata: zApiResourceMeta,
                  readableId: z.string(),
                  tenantId: z.string(),
                  jobId: z.string(),
                  action: z.string(),
                  timeout: z.string().optional(),
                  children: z.array(z.string()).optional(),
                  parents: z.array(z.string()).optional(),
                }),
              ),
              timeout: z.string().optional(),
            }),
          )
          .optional(),
        tenantId: z.string(),
      }),
    )
    .optional(),
  pagination: zPaginationResponse.optional(),
});

export const zWorkflowTriggers = z.object({
  metadata: zApiResourceMeta.optional(),
  workflow_version_id: z.string().optional(),
  tenant_id: z.string().optional(),
  events: z
    .array(
      z.object({
        parent_id: z.string().optional(),
        event_key: z.string().optional(),
      }),
    )
    .optional(),
  crons: z
    .array(
      z.object({
        parent_id: z.string().optional(),
        cron: z.string().optional(),
      }),
    )
    .optional(),
});

export const zWorkflowTriggerEventRef = z.object({
  parent_id: z.string().optional(),
  event_key: z.string().optional(),
});

export const zWorkflowTriggerCronRef = z.object({
  parent_id: z.string().optional(),
  cron: z.string().optional(),
});

export const zJob = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  versionId: z.string(),
  name: z.string(),
  description: z.string().optional(),
  steps: z.array(
    z.object({
      metadata: zApiResourceMeta,
      readableId: z.string(),
      tenantId: z.string(),
      jobId: z.string(),
      action: z.string(),
      timeout: z.string().optional(),
      children: z.array(z.string()).optional(),
      parents: z.array(z.string()).optional(),
    }),
  ),
  timeout: z.string().optional(),
});

export const zStep = z.object({
  metadata: zApiResourceMeta,
  readableId: z.string(),
  tenantId: z.string(),
  jobId: z.string(),
  action: z.string(),
  timeout: z.string().optional(),
  children: z.array(z.string()).optional(),
  parents: z.array(z.string()).optional(),
});

export const zWorkflowWorkersCount = z.object({
  freeSlotCount: z.number().int().optional(),
  maxSlotCount: z.number().int().optional(),
  workflowRunId: z.string().optional(),
});

export const zWorkflowRun: z.ZodTypeAny = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  workflowVersionId: z.string(),
  workflowVersion: zWorkflowVersion.optional(),
  status: z.enum(["PENDING", "RUNNING", "SUCCEEDED", "FAILED", "CANCELLED", "QUEUED", "BACKOFF"]),
  displayName: z.string().optional(),
  jobRuns: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        tenantId: z.string(),
        workflowRunId: z.string(),
        workflowRun: z
          .lazy(() => {
            return zWorkflowRun;
          })
          .optional(),
        jobId: z.string(),
        job: zJob.optional(),
        tickerId: z.string().optional(),
        stepRuns: z
          .array(
            z.object({
              metadata: zApiResourceMeta,
              tenantId: z.string(),
              jobRunId: z.string(),
              stepId: z.string(),
              step: zStep.optional(),
              childWorkflowsCount: z.number().int().optional(),
              parents: z.array(z.string()).optional(),
              childWorkflowRuns: z.array(z.string()).optional(),
              workerId: z.string().optional(),
              input: z.string().optional(),
              output: z.string().optional(),
              status: z.enum([
                "PENDING",
                "PENDING_ASSIGNMENT",
                "ASSIGNED",
                "RUNNING",
                "SUCCEEDED",
                "FAILED",
                "CANCELLED",
                "CANCELLING",
                "BACKOFF",
              ]),
              requeueAfter: z.string().datetime().optional(),
              result: z.object({}).optional(),
              error: z.string().optional(),
              startedAt: z.string().datetime().optional(),
              startedAtEpoch: z.number().int().optional(),
              finishedAt: z.string().datetime().optional(),
              finishedAtEpoch: z.number().int().optional(),
              timeoutAt: z.string().datetime().optional(),
              timeoutAtEpoch: z.number().int().optional(),
              cancelledAt: z.string().datetime().optional(),
              cancelledAtEpoch: z.number().int().optional(),
              cancelledReason: z.string().optional(),
              cancelledError: z.string().optional(),
            }),
          )
          .optional(),
        status: z.enum(["PENDING", "RUNNING", "SUCCEEDED", "FAILED", "CANCELLED", "BACKOFF"]),
        result: z.object({}).optional(),
        startedAt: z.string().datetime().optional(),
        finishedAt: z.string().datetime().optional(),
        timeoutAt: z.string().datetime().optional(),
        cancelledAt: z.string().datetime().optional(),
        cancelledReason: z.string().optional(),
        cancelledError: z.string().optional(),
      }),
    )
    .optional(),
  triggeredBy: z.object({
    metadata: zApiResourceMeta,
    parentWorkflowRunId: z.string().optional(),
    eventId: z.string().optional(),
    cronParentId: z.string().optional(),
    cronSchedule: z.string().optional(),
  }),
  input: z.object({}).optional(),
  error: z.string().optional(),
  startedAt: z.string().datetime().optional(),
  finishedAt: z.string().datetime().optional(),
  duration: z.number().int().optional(),
  parentId: z.string().uuid().length(36).optional(),
  parentStepRunId: z.string().uuid().length(36).optional(),
  additionalMetadata: z.object({}).optional(),
});

export const zWorkflowRunShape = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  workflowId: z.string().optional(),
  workflowVersionId: z.string(),
  workflowVersion: zWorkflowVersion.optional(),
  status: z.enum(["PENDING", "RUNNING", "SUCCEEDED", "FAILED", "CANCELLED", "QUEUED", "BACKOFF"]),
  displayName: z.string().optional(),
  jobRuns: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        tenantId: z.string(),
        workflowRunId: z.string(),
        workflowRun: zWorkflowRun.optional(),
        jobId: z.string(),
        job: zJob.optional(),
        tickerId: z.string().optional(),
        stepRuns: z
          .array(
            z.object({
              metadata: zApiResourceMeta,
              tenantId: z.string(),
              jobRunId: z.string(),
              stepId: z.string(),
              step: zStep.optional(),
              childWorkflowsCount: z.number().int().optional(),
              parents: z.array(z.string()).optional(),
              childWorkflowRuns: z.array(z.string()).optional(),
              workerId: z.string().optional(),
              input: z.string().optional(),
              output: z.string().optional(),
              status: z.enum([
                "PENDING",
                "PENDING_ASSIGNMENT",
                "ASSIGNED",
                "RUNNING",
                "SUCCEEDED",
                "FAILED",
                "CANCELLED",
                "CANCELLING",
                "BACKOFF",
              ]),
              requeueAfter: z.string().datetime().optional(),
              result: z.object({}).optional(),
              error: z.string().optional(),
              startedAt: z.string().datetime().optional(),
              startedAtEpoch: z.number().int().optional(),
              finishedAt: z.string().datetime().optional(),
              finishedAtEpoch: z.number().int().optional(),
              timeoutAt: z.string().datetime().optional(),
              timeoutAtEpoch: z.number().int().optional(),
              cancelledAt: z.string().datetime().optional(),
              cancelledAtEpoch: z.number().int().optional(),
              cancelledReason: z.string().optional(),
              cancelledError: z.string().optional(),
            }),
          )
          .optional(),
        status: z.enum(["PENDING", "RUNNING", "SUCCEEDED", "FAILED", "CANCELLED", "BACKOFF"]),
        result: z.object({}).optional(),
        startedAt: z.string().datetime().optional(),
        finishedAt: z.string().datetime().optional(),
        timeoutAt: z.string().datetime().optional(),
        cancelledAt: z.string().datetime().optional(),
        cancelledReason: z.string().optional(),
        cancelledError: z.string().optional(),
      }),
    )
    .optional(),
  triggeredBy: z.object({
    metadata: zApiResourceMeta,
    parentWorkflowRunId: z.string().optional(),
    eventId: z.string().optional(),
    cronParentId: z.string().optional(),
    cronSchedule: z.string().optional(),
  }),
  input: z.object({}).optional(),
  error: z.string().optional(),
  startedAt: z.string().datetime().optional(),
  finishedAt: z.string().datetime().optional(),
  duration: z.number().int().optional(),
  parentId: z.string().uuid().length(36).optional(),
  parentStepRunId: z.string().uuid().length(36).optional(),
  additionalMetadata: z.object({}).optional(),
});

export const zReplayWorkflowRunsRequest = z.object({
  workflowRunIds: z.array(z.string().uuid().length(36)),
});

export const zReplayWorkflowRunsResponse = z.object({
  workflowRuns: z.array(zWorkflowRun),
});

export const zWorkflowRunList = z.object({
  rows: z.array(zWorkflowRun).optional(),
  pagination: zPaginationResponse.optional(),
});

export const zScheduledWorkflows = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  workflowVersionId: z.string(),
  workflowId: z.string(),
  workflowName: z.string(),
  triggerAt: z.string().datetime(),
  input: z.object({}).optional(),
  additionalMetadata: z.object({}).optional(),
  workflowRunCreatedAt: z.string().datetime().optional(),
  workflowRunName: z.string().optional(),
  workflowRunStatus: z
    .enum(["PENDING", "RUNNING", "SUCCEEDED", "FAILED", "CANCELLED", "QUEUED", "BACKOFF"])
    .optional(),
  workflowRunId: z.string().uuid().length(36).optional(),
  method: z.enum(["DEFAULT", "API"]),
  priority: z.number().int().gte(1).lte(3).optional(),
});

export const zScheduledWorkflowsList = z.object({
  rows: z.array(zScheduledWorkflows).optional(),
  pagination: zPaginationResponse.optional(),
});

export const zScheduledWorkflowsOrderByField = z.enum(["triggerAt", "createdAt"]);

export const zScheduledRunStatus = z.enum([
  "PENDING",
  "RUNNING",
  "SUCCEEDED",
  "FAILED",
  "CANCELLED",
  "QUEUED",
  "SCHEDULED",
]);

export const zCronWorkflows = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  workflowVersionId: z.string(),
  workflowId: z.string(),
  workflowName: z.string(),
  cron: z.string(),
  name: z.string().optional(),
  input: z.object({}).optional(),
  additionalMetadata: z.object({}).optional(),
  enabled: z.boolean(),
  method: z.enum(["DEFAULT", "API"]),
  priority: z.number().int().gte(1).lte(3).optional(),
});

export const zCronWorkflowsList = z.object({
  rows: z.array(zCronWorkflows).optional(),
  pagination: zPaginationResponse.optional(),
});

export const zCronWorkflowsOrderByField = z.enum(["name", "createdAt"]);

export const zWorkflowRunOrderByField = z.enum([
  "createdAt",
  "startedAt",
  "finishedAt",
  "duration",
]);

export const zWorkflowRunOrderByDirection = z.enum(["ASC", "DESC"]);

export const zWorkflowRunsMetrics = z.object({
  counts: z
    .object({
      PENDING: z.number().int().optional(),
      RUNNING: z.number().int().optional(),
      SUCCEEDED: z.number().int().optional(),
      FAILED: z.number().int().optional(),
      QUEUED: z.number().int().optional(),
      CANCELLED: z.number().int().optional(),
    })
    .optional(),
});

export const zWorkflowRunsMetricsCounts = z.object({
  PENDING: z.number().int().optional(),
  RUNNING: z.number().int().optional(),
  SUCCEEDED: z.number().int().optional(),
  FAILED: z.number().int().optional(),
  QUEUED: z.number().int().optional(),
  CANCELLED: z.number().int().optional(),
});

export const zWorkflowRunStatus = z.enum([
  "PENDING",
  "RUNNING",
  "SUCCEEDED",
  "FAILED",
  "CANCELLED",
  "QUEUED",
  "BACKOFF",
]);

export const zWorkflowRunStatusList = z.array(zWorkflowRunStatus);

export const zWorkflowKind = z.enum(["FUNCTION", "DURABLE", "DAG"]);

export const zWorkflowKindList = z.array(zWorkflowKind);

export const zWorkflowRunsCancelRequest = z.object({
  workflowRunIds: z.array(z.string().uuid().length(36)),
});

export const zJobRunStatus = z.enum([
  "PENDING",
  "RUNNING",
  "SUCCEEDED",
  "FAILED",
  "CANCELLED",
  "BACKOFF",
]);

export const zStepRunStatus = z.enum([
  "PENDING",
  "PENDING_ASSIGNMENT",
  "ASSIGNED",
  "RUNNING",
  "SUCCEEDED",
  "FAILED",
  "CANCELLED",
  "CANCELLING",
  "BACKOFF",
]);

export const zJobRun = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  workflowRunId: z.string(),
  workflowRun: zWorkflowRun.optional(),
  jobId: z.string(),
  job: zJob.optional(),
  tickerId: z.string().optional(),
  stepRuns: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        tenantId: z.string(),
        jobRunId: z.string(),
        stepId: z.string(),
        step: zStep.optional(),
        childWorkflowsCount: z.number().int().optional(),
        parents: z.array(z.string()).optional(),
        childWorkflowRuns: z.array(z.string()).optional(),
        workerId: z.string().optional(),
        input: z.string().optional(),
        output: z.string().optional(),
        status: zStepRunStatus,
        requeueAfter: z.string().datetime().optional(),
        result: z.object({}).optional(),
        error: z.string().optional(),
        startedAt: z.string().datetime().optional(),
        startedAtEpoch: z.number().int().optional(),
        finishedAt: z.string().datetime().optional(),
        finishedAtEpoch: z.number().int().optional(),
        timeoutAt: z.string().datetime().optional(),
        timeoutAtEpoch: z.number().int().optional(),
        cancelledAt: z.string().datetime().optional(),
        cancelledAtEpoch: z.number().int().optional(),
        cancelledReason: z.string().optional(),
        cancelledError: z.string().optional(),
      }),
    )
    .optional(),
  status: zJobRunStatus,
  result: z.object({}).optional(),
  startedAt: z.string().datetime().optional(),
  finishedAt: z.string().datetime().optional(),
  timeoutAt: z.string().datetime().optional(),
  cancelledAt: z.string().datetime().optional(),
  cancelledReason: z.string().optional(),
  cancelledError: z.string().optional(),
});

export const zWorkflowRunTriggeredBy = z.object({
  metadata: zApiResourceMeta,
  parentWorkflowRunId: z.string().optional(),
  eventId: z.string().optional(),
  cronParentId: z.string().optional(),
  cronSchedule: z.string().optional(),
});

export const zStepRun = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string(),
  jobRunId: z.string(),
  stepId: z.string(),
  step: zStep.optional(),
  childWorkflowsCount: z.number().int().optional(),
  parents: z.array(z.string()).optional(),
  childWorkflowRuns: z.array(z.string()).optional(),
  workerId: z.string().optional(),
  input: z.string().optional(),
  output: z.string().optional(),
  status: zStepRunStatus,
  requeueAfter: z.string().datetime().optional(),
  result: z.object({}).optional(),
  error: z.string().optional(),
  startedAt: z.string().datetime().optional(),
  startedAtEpoch: z.number().int().optional(),
  finishedAt: z.string().datetime().optional(),
  finishedAtEpoch: z.number().int().optional(),
  timeoutAt: z.string().datetime().optional(),
  timeoutAtEpoch: z.number().int().optional(),
  cancelledAt: z.string().datetime().optional(),
  cancelledAtEpoch: z.number().int().optional(),
  cancelledReason: z.string().optional(),
  cancelledError: z.string().optional(),
});

export const zStepRunEventReason = z.enum([
  "REQUEUED_NO_WORKER",
  "REQUEUED_RATE_LIMIT",
  "SCHEDULING_TIMED_OUT",
  "ASSIGNED",
  "STARTED",
  "ACKNOWLEDGED",
  "FINISHED",
  "FAILED",
  "RETRYING",
  "CANCELLED",
  "TIMEOUT_REFRESHED",
  "REASSIGNED",
  "TIMED_OUT",
  "SLOT_RELEASED",
  "RETRIED_BY_USER",
  "WORKFLOW_RUN_GROUP_KEY_SUCCEEDED",
  "WORKFLOW_RUN_GROUP_KEY_FAILED",
]);

export const zStepRunEventSeverity = z.enum(["INFO", "WARNING", "CRITICAL"]);

export const zStepRunEvent = z.object({
  id: z.number().int(),
  timeFirstSeen: z.string().datetime(),
  timeLastSeen: z.string().datetime(),
  stepRunId: z.string().optional(),
  workflowRunId: z.string().optional(),
  reason: zStepRunEventReason,
  severity: zStepRunEventSeverity,
  message: z.string(),
  count: z.number().int(),
  data: z.object({}).optional(),
});

export const zStepRunEventList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zStepRunEvent).optional(),
});

export const zStepRunArchive = z.object({
  stepRunId: z.string(),
  order: z.number().int(),
  input: z.string().optional(),
  output: z.string().optional(),
  startedAt: z.string().datetime().optional(),
  error: z.string().optional(),
  retryCount: z.number().int(),
  createdAt: z.string().datetime(),
  startedAtEpoch: z.number().int().optional(),
  finishedAt: z.string().datetime().optional(),
  finishedAtEpoch: z.number().int().optional(),
  timeoutAt: z.string().datetime().optional(),
  timeoutAtEpoch: z.number().int().optional(),
  cancelledAt: z.string().datetime().optional(),
  cancelledAtEpoch: z.number().int().optional(),
  cancelledReason: z.string().optional(),
  cancelledError: z.string().optional(),
});

export const zStepRunArchiveList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zStepRunArchive).optional(),
});

export const zWorkerRuntimeInfo = z.object({
  sdkVersion: z.string().optional(),
  language: z.enum(["GOLANG", "PYTHON", "TYPESCRIPT"]).optional(),
  languageVersion: z.string().optional(),
  os: z.string().optional(),
  runtimeExtra: z.string().optional(),
});

export const zWorkerRuntimeSdks = z.enum(["GOLANG", "PYTHON", "TYPESCRIPT"]);

export const zWorkerList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        name: z.string(),
        type: z.enum(["SELFHOSTED", "MANAGED", "WEBHOOK"]),
        lastHeartbeatAt: z.string().datetime().optional(),
        lastListenerEstablished: z.string().datetime().optional(),
        actions: z.array(z.string()).optional(),
        slots: z
          .array(
            z.object({
              stepRunId: z.string().uuid(),
              actionId: z.string(),
              startedAt: z.string().datetime().optional(),
              timeoutAt: z.string().datetime().optional(),
              workflowRunId: z.string().uuid(),
              status: zStepRunStatus,
            }),
          )
          .optional(),
        recentStepRuns: z
          .array(
            z.object({
              metadata: zApiResourceMeta,
              actionId: z.string(),
              status: zStepRunStatus,
              startedAt: z.string().datetime().optional(),
              finishedAt: z.string().datetime().optional(),
              cancelledAt: z.string().datetime().optional(),
              workflowRunId: z.string().uuid(),
            }),
          )
          .optional(),
        status: z.enum(["ACTIVE", "INACTIVE", "PAUSED"]).optional(),
        maxRuns: z.number().int().optional(),
        availableRuns: z.number().int().optional(),
        dispatcherId: z.string().uuid().length(36).optional(),
        labels: z
          .array(
            z.object({
              metadata: zApiResourceMeta,
              key: z.string(),
              value: z.string().optional(),
            }),
          )
          .optional(),
        webhookUrl: z.string().optional(),
        webhookId: z.string().uuid().optional(),
        runtimeInfo: zWorkerRuntimeInfo.optional(),
      }),
    )
    .optional(),
});

export const zSemaphoreSlots = z.object({
  stepRunId: z.string().uuid(),
  actionId: z.string(),
  startedAt: z.string().datetime().optional(),
  timeoutAt: z.string().datetime().optional(),
  workflowRunId: z.string().uuid(),
  status: zStepRunStatus,
});

export const zRecentStepRuns = z.object({
  metadata: zApiResourceMeta,
  actionId: z.string(),
  status: zStepRunStatus,
  startedAt: z.string().datetime().optional(),
  finishedAt: z.string().datetime().optional(),
  cancelledAt: z.string().datetime().optional(),
  workflowRunId: z.string().uuid(),
});

export const zWorker = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  type: z.enum(["SELFHOSTED", "MANAGED", "WEBHOOK"]),
  lastHeartbeatAt: z.string().datetime().optional(),
  lastListenerEstablished: z.string().datetime().optional(),
  actions: z.array(z.string()).optional(),
  slots: z.array(zSemaphoreSlots).optional(),
  recentStepRuns: z.array(zRecentStepRuns).optional(),
  status: z.enum(["ACTIVE", "INACTIVE", "PAUSED"]).optional(),
  maxRuns: z.number().int().optional(),
  availableRuns: z.number().int().optional(),
  dispatcherId: z.string().uuid().length(36).optional(),
  labels: z
    .array(
      z.object({
        metadata: zApiResourceMeta,
        key: z.string(),
        value: z.string().optional(),
      }),
    )
    .optional(),
  webhookUrl: z.string().optional(),
  webhookId: z.string().uuid().optional(),
  runtimeInfo: zWorkerRuntimeInfo.optional(),
});

export const zWorkerLabel = z.object({
  metadata: zApiResourceMeta,
  key: z.string(),
  value: z.string().optional(),
});

export const zUpdateWorkerRequest = z.object({
  isPaused: z.boolean().optional(),
});

export const zApiToken = z.object({
  metadata: zApiResourceMeta,
  name: z.string().max(255),
  expiresAt: z.string().datetime(),
});

export const zCreateApiTokenRequest = z.object({
  name: z.string().max(255),
  expiresIn: z.string().optional(),
});

export const zCreateApiTokenResponse = z.object({
  token: z.string(),
});

export const zListApiTokensResponse = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zApiToken).optional(),
});

export const zRerunStepRunRequest = z.object({
  input: z.object({}),
});

export const zTriggerWorkflowRunRequest = z.object({
  input: z.object({}),
  additionalMetadata: z.object({}).optional(),
});

export const zScheduleWorkflowRunRequest = z.object({
  input: z.object({}),
  additionalMetadata: z.object({}),
  triggerAt: z.string().datetime(),
  priority: z.number().int().gte(1).lte(3).optional(),
});

export const zCreateCronWorkflowTriggerRequest = z.object({
  input: z.object({}),
  additionalMetadata: z.object({}),
  cronName: z.string(),
  cronExpression: z.string(),
  priority: z.number().int().gte(1).lte(3).optional(),
});

export const zCreatePullRequestFromStepRun = z.object({
  branchName: z.string(),
});

export const zGetStepRunDiffResponse = z.object({
  diffs: z.array(
    z.object({
      key: z.string(),
      original: z.string(),
      modified: z.string(),
    }),
  ),
});

export const zStepRunDiff = z.object({
  key: z.string(),
  original: z.string(),
  modified: z.string(),
});

export const zListPullRequestsResponse = z.object({
  pullRequests: z.array(
    z.object({
      repositoryOwner: z.string(),
      repositoryName: z.string(),
      pullRequestID: z.number().int(),
      pullRequestTitle: z.string(),
      pullRequestNumber: z.number().int(),
      pullRequestHeadBranch: z.string(),
      pullRequestBaseBranch: z.string(),
      pullRequestState: z.enum(["open", "closed"]),
    }),
  ),
});

export const zPullRequest = z.object({
  repositoryOwner: z.string(),
  repositoryName: z.string(),
  pullRequestID: z.number().int(),
  pullRequestTitle: z.string(),
  pullRequestNumber: z.number().int(),
  pullRequestHeadBranch: z.string(),
  pullRequestBaseBranch: z.string(),
  pullRequestState: z.enum(["open", "closed"]),
});

export const zPullRequestState = z.enum(["open", "closed"]);

export const zLogLine = z.object({
  createdAt: z.string().datetime(),
  message: z.string(),
  metadata: z.object({}),
});

export const zLogLineLevel = z.enum(["DEBUG", "INFO", "WARN", "ERROR"]);

export const zLogLineList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zLogLine).optional(),
});

export const zLogLineOrderByField = z.enum(["createdAt"]);

export const zLogLineOrderByDirection = z.enum(["asc", "desc"]);

export const zLogLineSearch = z.string();

export const zLogLineLevelField = z.array(zLogLineLevel);

export const zSnsIntegration = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string().uuid(),
  topicArn: z.string(),
  ingestUrl: z.string().optional(),
});

export const zListSnsIntegrations = z.object({
  pagination: zPaginationResponse,
  rows: z.array(zSnsIntegration),
});

export const zSlackWebhook = z.object({
  metadata: zApiResourceMeta,
  tenantId: z.string().uuid(),
  teamName: z.string(),
  teamId: z.string(),
  channelName: z.string(),
  channelId: z.string(),
});

export const zListSlackWebhooks = z.object({
  pagination: zPaginationResponse,
  rows: z.array(zSlackWebhook),
});

export const zCreateSnsIntegrationRequest = z.object({
  topicArn: z.string(),
});

export const zWorkflowMetrics = z.object({
  groupKeyRunsCount: z.number().int().optional(),
  groupKeyCount: z.number().int().optional(),
});

export const zWebhookWorker = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  url: z.string(),
});

export const zWebhookWorkerRequestMethod = z.enum(["GET", "POST", "PUT"]);

export const zWebhookWorkerRequest = z.object({
  created_at: z.string().datetime(),
  method: zWebhookWorkerRequestMethod,
  statusCode: z.number().int(),
});

export const zWebhookWorkerRequestListResponse = z.object({
  requests: z.array(zWebhookWorkerRequest).optional(),
});

export const zWebhookWorkerCreated = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  url: z.string(),
  secret: z.string(),
});

export const zWebhookWorkerCreateRequest = z.object({
  name: z.string(),
  url: z.string(),
  secret: z.string().min(32).optional(),
});

export const zWebhookWorkerCreateResponse = z.object({
  worker: zWebhookWorkerCreated.optional(),
});

export const zWebhookWorkerListResponse = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zWebhookWorker).optional(),
});

export const zTenantVersion = z.enum(["V0", "V1"]);

export const zApiResourceMetaProperties = z.object({
  metadata: zApiResourceMeta,
});

export const zCommonResult = z.object({
  Success: z.boolean(),
  Message: z.string(),
});

export const zTenantParameter = z.string().uuid().length(36);

export const zModel = zApiResourceMetaProperties.merge(
  z.object({
    name: z.string(),
    model: z.string(),
    provider: z.string(),
    apiKey: z.string(),
    apiBase: z.string(),
    vendor: z.string(),
    description: z.string().optional(),
    family: z.string(),
    vision: z.boolean(),
    functionCalling: z.boolean(),
    jsonOutput: z.boolean(),
    tags: z.array(z.string()).optional(),
  }),
);

export const zModelFamily = z.enum(["r1", "openai", "unknown"]);

export const zModelTypes = z.enum([
  "OpenAIChatCompletionClient",
  "AzureOpenAIChatCompletionClient",
]);

export const zModelProperties = z.object({
  name: z.string(),
  model: z.string(),
  provider: z.string(),
  apiKey: z.string(),
  apiBase: z.string(),
  vendor: z.string(),
  description: z.string().optional(),
  family: z.string(),
  vision: z.boolean(),
  functionCalling: z.boolean(),
  jsonOutput: z.boolean(),
  tags: z.array(z.string()).optional(),
});

export const zModelList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zModel).optional(),
});

export const zFormField = z.object({
  type: z.enum(["text", "number", "boolean", "array", "object"]),
  name: z.string(),
  default_value: z.string().optional(),
  label: z.string().optional(),
  description: z.string().optional(),
  required: z.boolean().optional(),
  min: z.number().optional(),
  max: z.number().optional(),
  placeholder: z.string().optional(),
});

export const zSchemaForm = z.object({
  form_type: z.enum(["schema", "custom"]).optional(),
  form_name: z.string().optional(),
  title: z.string(),
  description: z.string().optional(),
  layout: z.enum(["vertical", "horizontal"]).optional(),
  fields: z.array(zFormField),
});

export const zModelRunProperties = z.object({
  llmMessages: z.object({}).optional(),
  llmResponse: z.object({}).optional(),
});

export const zModelRun = zApiResourceMetaProperties.merge(zModelRunProperties);

export const zModelRunList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zModelRun).optional(),
});

export const zModelRunUpsert = zModelRunProperties;

export const zSiteProperties = z.object({
  id: z.string(),
  tenant_id: z.string(),
  updated_at: z.string().optional(),
  created_at: z.string().optional(),
  enabled: z.boolean(),
  title: z.string(),
  description: z.string(),
  automation_enabled: z.boolean(),
  state: z.object({
    status: z.string().optional(),
  }),
});

export const zSite = zSiteProperties;

export const zSiteList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zSite).optional(),
});

export const zCreateSiteRequest = z.object({
  title: z.string(),
  description: z.string(),
  host: z.string().optional(),
});

export const zCreateSiteResponse = zSite;

export const zUpdateSiteRequest = z.object({
  title: z.string().optional(),
});

export const zSiteHostProperties = z.object({
  id: z.string(),
  title: z.string().optional(),
  description: z.string().optional(),
  host: z.string(),
});

export const zSiteHost = zSiteHostProperties;

export const zSiteHostList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zSiteHost).optional(),
});

export const zCreateSiteHostRequest = zSiteHostProperties;

export const zUpdateSiteHostRequest = zSiteHost;

export const zFrontendConfig = z.object({
  cookieAccessToken: z.string(),
  dashPath: z.string(),
  hotKeyDebug: z.string(),
  defaultTenantAccessToken: z.string(),
});

export const zSiderbarConfig = z.object({
  logo: z.string().optional(),
  sideritems: z
    .array(
      z.object({
        title: z.string(),
        url: z.string(),
        icon: z.string().optional(),
        defaultExpanded: z.boolean().optional(),
        adminOnly: z.boolean().optional(),
        children: z
          .array(
            z.object({
              title: z.string(),
              url: z.string(),
              icon: z.string().optional(),
              adminOnly: z.boolean().optional(),
            }),
          )
          .optional(),
      }),
    )
    .optional(),
  other: z
    .union([
      z.enum([
        "sys",
        "tenant",
        "assistant",
        "ag",
        "browser",
        "resource",
        "instagram",
        "social",
        "team",
        "adk",
      ]),
      z.enum([
        "ThoughtEvent",
        "TextMessage",
        "PlatformAccountFlowInput",
        "ChatMessageInput",
        "SocialAddFollowersInput",
        "SocialLoginInput",
        "TenantInitInput",
        "AskUserFunctionCallInput",
        "StartNewChatInput",
      ]),
      z.object({
        pagination: zPaginationResponse.optional(),
        rows: z
          .array(
            zApiResourceMetaProperties.merge(
              z.object({
                label: z.string().optional(),
                description: z.string().optional(),
                username: z.string(),
                email: z.string().optional(),
                password: z.string(),
                token: z.string().optional(),
                type: z.string().optional(),
                platform: z.string(),
                enabled: z.boolean().optional(),
                tags: z.array(z.string()).optional(),
                state: z.object({}).optional(),
                error: z.string().optional(),
              }),
            ),
          )
          .optional(),
      }),
      z.object({
        role: z.string().optional(),
        parts: z
          .array(
            z.object({
              text: z.string().optional(),
              video_metadata: z.object({}).optional(),
              thought: z.boolean().optional(),
              code_execution_result: z.object({}).optional(),
              executable_code: z.string().optional(),
              file_data: z.object({}).optional(),
              function_call: z.object({}).optional(),
              function_response: z.object({}).optional(),
              inline_data: z.object({}).optional(),
            }),
          )
          .optional(),
      }),
      z.object({
        text: z.string().optional(),
        video_metadata: z.object({}).optional(),
        thought: z.boolean().optional(),
        code_execution_result: z.object({}).optional(),
        executable_code: z.string().optional(),
        file_data: z.object({}).optional(),
        function_call: z.object({}).optional(),
        function_response: z.object({}).optional(),
        inline_data: z.object({}).optional(),
      }),
      z.object({
        pagination: zPaginationResponse.optional(),
        rows: z
          .array(
            zApiResourceMetaProperties.merge(
              z.object({
                id: z.string(),
                app_name: z.string(),
                user_id: z.string(),
                state: z.object({
                  type: z.enum(["RootAgentState"]).optional(),
                }),
                title: z.string().optional(),
                create_time: z.string(),
                update_time: z.string(),
              }),
            ),
          )
          .optional(),
      }),
      z.object({
        content: z.string().optional(),
      }),
      z.object({
        content: z.string().optional(),
      }),
    ])
    .optional(),
});

export const zDashSidebarItem = z.object({
  title: z.string(),
  url: z.string(),
  icon: z.string().optional(),
  defaultExpanded: z.boolean().optional(),
  adminOnly: z.boolean().optional(),
  children: z
    .array(
      z.object({
        title: z.string(),
        url: z.string(),
        icon: z.string().optional(),
        adminOnly: z.boolean().optional(),
      }),
    )
    .optional(),
});

export const zDashSidebarItemLeaf = z.object({
  title: z.string(),
  url: z.string(),
  icon: z.string().optional(),
  adminOnly: z.boolean().optional(),
});

export const zUpdateEndpointRequest = z.object({
  name: z.string().optional(),
  url: z.string().optional(),
  token: z.string().optional(),
});

export const zEndpoint = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  url: z.string(),
  token: z.string(),
  type: z.string(),
});

export const zEndpointList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zEndpoint).optional(),
});

export const zMtWorkerProperties = z.object({
  id: z.string().optional(),
  name: z.string().optional(),
});

export const zMtWorkerTask = z.object({
  id: z.string().optional(),
  name: z.string().optional(),
});

export const zAgentEventType = z.enum([
  "ThoughtEvent",
  "TextMessage",
  "PlatformAccountFlowInput",
  "ChatMessageInput",
  "SocialAddFollowersInput",
  "SocialLoginInput",
  "TenantInitInput",
  "AskUserFunctionCallInput",
  "StartNewChatInput",
]);

export const zFlowNames = z.enum([
  "sys",
  "tenant",
  "assistant",
  "ag",
  "browser",
  "resource",
  "instagram",
  "social",
  "team",
  "adk",
]);

export const zAgentRunnerInput = z.object({
  content: z.string().optional(),
});

export const zAgentRunnerOutput = z.object({
  content: z.string().optional(),
});

export const zAgentProperties = z.object({
  name: z.string(),
  description: z.string(),
  provider: z.string(),
  config: z.object({}),
  teamId: z.string(),
});

export const zAgent = zApiResourceMetaProperties.merge(zAgentProperties);

export const zAgentList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zAgent).optional(),
});

export const zAgentTopicTypes = z.enum([
  "user",
  "human",
  "instagram",
  "browser",
  "socioety",
  "code",
  "router",
  "research",
  "writer",
  "tenant",
  "closure",
  "response",
]);

export const zBrowserTask = z.object({
  content: z.string(),
});

export const zBrowserOpenTask = z.object({
  url: z.string(),
});

export const zBrowserConfig = z.object({
  persistent: z.boolean().optional(),
});

export const zScheduledItem = z.object({
  id: z.string(),
  type: z.enum(["cron", "scheduled", "delayed"]),
  trigger: z.string(),
  nextTrigger: z.string(),
  description: z.string(),
});

export const zAdkSessionState = z.object({
  type: z.enum(["RootAgentState"]).optional(),
});

export const zToolTypes = z.enum(["code_executor", "social_login"]);

export const zCodeExecutionInput = z.object({
  code: z.string(),
});

export const zCodeExecutionResult = z.object({
  output: z.string(),
  success: z.boolean(),
});

export const zSocialLoginResult = z.object({
  success: z.boolean(),
});

export const zPlatform = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  description: z.string().optional(),
  url: z.string(),
  loginUrl: z.string().optional(),
  properties: z.object({}).optional(),
  tags: z.array(z.string()).optional(),
});

export const zPlatformList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zPlatform).optional(),
});

export const zPlatformUpdate = z.object({
  metadata: zApiResourceMeta,
  name: z.string(),
  description: z.string().optional(),
  url: z.string(),
  loginUrl: z.string().optional(),
  properties: z.object({}).optional(),
  tags: z.array(z.string()).optional(),
});

export const zPlatformAccountProperties = z.object({
  label: z.string().optional(),
  description: z.string().optional(),
  username: z.string(),
  email: z.string().optional(),
  password: z.string(),
  token: z.string().optional(),
  type: z.string().optional(),
  platform: z.string(),
  enabled: z.boolean().optional(),
  tags: z.array(z.string()).optional(),
  state: z.object({}).optional(),
  error: z.string().optional(),
});

export const zPlatformAccountCreate = zPlatformAccountProperties;

export const zPlatformAccount = zApiResourceMetaProperties.merge(zPlatformAccountProperties);

export const zPlatformAccountList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zPlatformAccount).optional(),
});

export const zPlatformAccountUpsert = zPlatformAccountProperties;

export const zAdkEventProperties = z.object({
  id: z.string(),
  app_name: z.string(),
  user_id: z.string(),
  session_id: z.string(),
  invocation_id: z.string(),
  author: z.string(),
  branch: z.string().optional(),
  timestamp: z.string(),
  content: z.object({
    role: z.string().optional(),
    parts: z
      .array(
        z.object({
          text: z.string().optional(),
          video_metadata: z.object({}).optional(),
          thought: z.boolean().optional(),
          code_execution_result: z.object({}).optional(),
          executable_code: z.string().optional(),
          file_data: z.object({}).optional(),
          function_call: z.object({}).optional(),
          function_response: z.object({}).optional(),
          inline_data: z.object({}).optional(),
        }),
      )
      .optional(),
  }),
  actions: z.object({}),
});

export const zAdkEventList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zApiResourceMetaProperties.merge(zAdkEventProperties)).optional(),
});

export const zAdkEvent = zApiResourceMetaProperties.merge(zAdkEventProperties);

export const zAdkEventUpsert = zAdkEventProperties;

export const zAdkEventOrderByField = z.enum(["createdAt"]);

export const zAdkAppProperties = z.object({
  id: z.string(),
  app_name: z.string(),
  user_id: z.string(),
  session_id: z.string(),
  invocation_id: z.string(),
  author: z.string(),
  branch: z.string(),
  timestamp: z.string(),
  content: z.object({}),
  actions: z.object({}),
});

export const zAdkAppList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zApiResourceMetaProperties.merge(zAdkAppProperties)).optional(),
});

export const zAdkApp = zApiResourceMetaProperties.merge(zAdkAppProperties);

export const zAdkAppUpsert = zAdkAppProperties;

export const zAdkAppTypes = z.enum(["root", "instagram_agent", "assistant", "open_deep_research"]);

export const zAdkSessionProperties = z.object({
  id: z.string(),
  app_name: z.string(),
  user_id: z.string(),
  state: zAdkSessionState,
  title: z.string().optional(),
  create_time: z.string(),
  update_time: z.string(),
});

export const zAdkSession = zApiResourceMetaProperties.merge(zAdkSessionProperties);

export const zAdkSessionList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zAdkSession).optional(),
});

export const zAdkSessionUpsert = zAdkSessionProperties;

export const zAdkUserStateProperties = z.object({
  id: z.string(),
  app_name: z.string(),
  user_id: z.string(),
  session_id: z.string(),
  invocation_id: z.string(),
  author: z.string(),
  branch: z.string(),
  timestamp: z.string(),
  content: z.object({}),
  actions: z.object({}),
});

export const zAdkUserState = zApiResourceMetaProperties.merge(zAdkUserStateProperties);

export const zAdkUserStateList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zAdkUserState).optional(),
});

export const zAdkUserStateUpsert = zAdkUserStateProperties;

export const zContent = z.object({
  role: z.string().optional(),
  parts: z
    .array(
      z.object({
        text: z.string().optional(),
        video_metadata: z.object({}).optional(),
        thought: z.boolean().optional(),
        code_execution_result: z.object({}).optional(),
        executable_code: z.string().optional(),
        file_data: z.object({}).optional(),
        function_call: z.object({}).optional(),
        function_response: z.object({}).optional(),
        inline_data: z.object({}).optional(),
      }),
    )
    .optional(),
});

export const zUserContent = z.object({
  role: z.enum(["user"]),
  parts: z.array(
    z.object({
      text: z.string().optional(),
      video_metadata: z.object({}).optional(),
      thought: z.boolean().optional(),
      code_execution_result: z.object({}).optional(),
      executable_code: z.string().optional(),
      file_data: z.object({}).optional(),
      function_call: z.object({}).optional(),
      function_response: z.object({}).optional(),
      inline_data: z.object({}).optional(),
    }),
  ),
});

export const zModelContent = z.object({
  role: z.enum(["model"]),
  parts: z.array(
    z.object({
      text: z.string().optional(),
      video_metadata: z.object({}).optional(),
      thought: z.boolean().optional(),
      code_execution_result: z.object({}).optional(),
      executable_code: z.string().optional(),
      file_data: z.object({}).optional(),
      function_call: z.object({}).optional(),
      function_response: z.object({}).optional(),
      inline_data: z.object({}).optional(),
    }),
  ),
});

export const zPart = z.object({
  text: z.string().optional(),
  video_metadata: z.object({}).optional(),
  thought: z.boolean().optional(),
  code_execution_result: z.object({}).optional(),
  executable_code: z.string().optional(),
  file_data: z.object({}).optional(),
  function_call: z.object({}).optional(),
  function_response: z.object({}).optional(),
  inline_data: z.object({}).optional(),
});

export const zFunctionResponse = z.object({
  id: z.string().optional().default(""),
  name: z.string(),
  response: z.object({}),
});

export const zArtifact = z.object({
  id: z.string().uuid().length(36),
  created_at: z.string().datetime(),
  updated_at: z.string(),
  tenant_id: z.string().uuid().length(36),
  user_id: z.string(),
  version: z.number().int(),
  session_id: z.string(),
  app_name: z.string(),
  filename: z.string(),
  mime_type: z.string().optional(),
  content: z.string(),
});

export const zArtifactList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zArtifact).optional(),
});

export const zSaveArtifactRequest = z.object({
  app_name: z.string(),
  user_id: z.string(),
  session_id: z.string().optional(),
  filename: z.string().optional(),
  content: z.string().optional(),
});

export const zPost = z.object({
  metadata: zApiResourceMeta,
  title: z.string(),
  content: z.string(),
});

export const zPostList = z.object({
  pagination: zPaginationResponse.optional(),
  rows: z.array(zPost).optional(),
});

export const zCreatePostRequest = z.object({
  siteId: z.string().uuid().length(36),
  title: z.string().min(3).max(200),
  content: z.string().min(50).max(10240),
  slug: z.string().min(3).max(200),
  authorId: z.string().uuid().length(36).optional(),
  status: z.enum(["draft", "published"]).optional(),
});

export const zSandbox = z.object({
  id: z.string(),
  type: z.string(),
  url: z.string(),
});

export const zMtmInfo = z.object({
  message: z.string().optional(),
});

export const zBot = z.object({
  id: z.string(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
  name: z.string(),
  description: z.string(),
  config: z.object({
    public_server: z.string(),
    private_server: z.string(),
    frontend_url: z.string(),
    local_http_server_enabled: z.boolean(),
    local_http_server_port: z.number().int(),
    adb_server_enabled: z.boolean(),
    adb_server_port: z.number().int().optional().default(5555),
    hatchet_token: z.string(),
  }),
});

export const zBotList = z.object({
  pagination: zPaginationResponse,
  rows: z.array(zBot),
});

export const zBotConfig = z.object({
  public_server: z.string(),
  private_server: z.string(),
  frontend_url: z.string(),
  local_http_server_enabled: z.boolean(),
  local_http_server_port: z.number().int(),
  adb_server_enabled: z.boolean(),
  adb_server_port: z.number().int().optional().default(5555),
  hatchet_token: z.string(),
});

export const zBotLocalState = z.object({
  bot_id: z.string(),
  device_type: z.enum(["unknown", "android", "ios", "web"]),
  host_name: z.string(),
});

export const zSbWorkerProfile = z.object({
  frontendUrl: z.string(),
  isDebug: z.boolean(),
  autoStart: z.boolean(),
  defaultProfileName: z.string(),
  defaultProfileUrl: z.string(),
});

export const zSbOutbound = z.object({
  id: z.string().optional(),
  created_at: z.string().optional(),
  updated_at: z.string().optional(),
  tag: z.string().optional(),
  type: z.string().optional(),
  server: z.string().optional(),
  server_port: z.number().int().optional(),
  uuid: z.string().optional(),
});

export const zSbImportRequest = z.object({
  url: z.string(),
});

export const zMobileHello = z.object({
  message: z.string().optional(),
});

export const zEvent = z.object({
  key: z.string(),
  additionalMetadata: z.object({}),
});

export const zPushEventResponse = z.object({
  success: z.boolean(),
  error: z.object({}),
});

export const zMetadataGetResponse = zApiMeta;

export const zMetadataListIntegrationsResponse = zListApiMetaIntegration;

export const zUserUpdateLoginResponse = zUser;

export const zSnsListResponse = zListSnsIntegrations;

export const zSnsCreateResponse = zSnsIntegration;

export const zAlertEmailGroupListResponse = zTenantAlertEmailGroupList;

export const zAlertEmailGroupCreateResponse = zTenantAlertEmailGroup;

export const zTenantResourcePolicyGetResponse = zTenantResourcePolicy;

export const zAlertEmailGroupDeleteResponse = z.void();

export const zAlertEmailGroupUpdateResponse = zTenantAlertEmailGroup;

export const zSnsDeleteResponse = z.void();

export const zSlackWebhookListResponse = zListSlackWebhooks;

export const zSlackWebhookDeleteResponse = z.void();

export const zUserGetCurrentResponse = zUser;

export const zUserUpdatePasswordResponse = zUser;

export const zUserCreateResponse = zUser;

export const zUserUpdateLogoutResponse = zUser;

export const zTenantMembershipsListResponse = zUserTenantMembershipsList;

export const zUserListTenantInvitesResponse = zTenantInviteList;

export const zTenantCreateResponse = zTenant;

export const zTenantUpdateResponse = zTenant;

export const zTenantAlertingSettingsGetResponse = zTenantAlertingSettings;

export const zTenantInviteListResponse = zTenantInviteList;

export const zTenantInviteCreateResponse = zTenantInvite;

export const zTenantInviteDeleteResponse = zTenantInvite;

export const zTenantInviteUpdateResponse = zTenantInvite;

export const zApiTokenListResponse = zListApiTokensResponse;

export const zApiTokenCreateResponse = zCreateApiTokenResponse;

export const zApiTokenUpdateRevokeResponse = z.void();

export const zTenantMemberListResponse = zTenantMemberList;

export const zTenantMemberDeleteResponse = zTenantMember;

export const zInfoGetVersionResponse = z.object({
  version: z.string(),
});

export const zEventPushResponse = zPushEventResponse;

export const zSiteListResponse = zSiteList;

export const zSiteCreateResponse = zSite;

export const zSiteGetResponse = zSite;

export const zSiteUpdateResponse = zSite;

export const zSiteGetByHostResponse = zSite;

export const zSiteHostListResponse = zSiteHostList;

export const zSiteHostCreateResponse = zSiteHost;

export const zSiteHostGetResponse = zSiteHost;

export const zSiteHostUpdateResponse = zSiteHost;

export const zFrontendGetConfigResponse = zFrontendConfig;

export const zFrontendGetSiderbarResponse = zSiderbarConfig;

export const zEndpointListResponse = zEndpointList;

export const zEndpointUpdateResponse = zEndpoint;

export const zMtworkerGetTasksResponse = zMtWorkerTask;

export const zPostListPublicResponse = zPostList;

export const zPostGetResponse = zPost;

export const zPostListResponse = zPostList;

export const zPostCreateResponse = zPost;

export const zArtifactListResponse = zArtifactList;

export const zArtifactGetResponse = zArtifact;

export const zArtifactSaveResponse = zArtifact;

export const zSandboxGetResponse = zSandbox;

export const zMtmHelloResponse = zMtmInfo;

export const zScriptsByNameResponse = z.string();

export const zSingboxGetWorkerProfileResponse = zSbWorkerProfile;

export const zSingboxSubscribeResponse = z.object({});

export const zSingboxGeoipCnSrsResponse = z.string();

export const zSingboxGetOutboundsResponse = zSbOutbound;

export const zSingboxImportOutboundsResponse = zSbOutbound;

export const zBotListResponse = zBotList;

export const zBotGetResponse = zBot;

export const zBotHeartbeatResponse = zBotConfig;
